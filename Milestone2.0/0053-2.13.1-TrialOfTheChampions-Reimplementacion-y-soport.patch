From 2fd6c1eecf0bd81ff4729685eaf8f7fa76202e52 Mon Sep 17 00:00:00 2001
From: Eilo <eilo2518@gmail.com>
Date: Mon, 6 Feb 2012 20:03:49 -0500
Subject: [PATCH 53/65] 2.13.1 TrialOfTheChampions: Reimplementacion y soporte

---
 .../world/reanemu/2011_12_25_100_world_toc5.sql    |  696 +++++++++
 src/server/game/Spells/SpellEffects.cpp            |   62 +
 src/server/game/Texts/CreatureTextMgr.cpp          |    4 +
 .../TrialOfTheChampion/boss_argent_challenge.cpp   |  769 +++++++---
 .../TrialOfTheChampion/boss_black_knight.cpp       |  306 +++-
 .../TrialOfTheChampion/boss_grand_champions.cpp    | 1500 +++++++++++-------
 .../instance_trial_of_the_champion.cpp             |  420 ++++--
 .../TrialOfTheChampion/trial_of_the_champion.cpp   | 1632 ++++++++++++++++----
 .../TrialOfTheChampion/trial_of_the_champion.h     |  210 +++-
 9 files changed, 4226 insertions(+), 1373 deletions(-)
 create mode 100644 sql/updates/world/reanemu/2011_12_25_100_world_toc5.sql

diff --git a/sql/updates/world/reanemu/2011_12_25_100_world_toc5.sql b/sql/updates/world/reanemu/2011_12_25_100_world_toc5.sql
new file mode 100644
index 0000000..c2ada1d
--- /dev/null
+++ b/sql/updates/world/reanemu/2011_12_25_100_world_toc5.sql
@@ -0,0 +1,696 @@
+-- Eilo (https://github.com/eilo)
+-- Recopilacion y adecuacion de querys originales de HyD y varios autores de scripts antiguas y raras
+-- Algunas querys anadidas y ordenacion/comentarios del sql por Eilo, cabe recalcar que los cpp hubo que retocar tambien.
+
+-- INSTANCE: TrialOfTheChampion
+-- ----------------------
+--    TEMPLATES HERO
+-- ----------------------
+-- Templates
+DELETE FROM `creature_template` WHERE `entry` IN (12000, 12001, 12002, 12003, 12004, 12005, 12006, 12007, 12008, 12009, 12010, 12011, 12444, 12436);
+UPDATE `creature_template` SET `difficulty_entry_1` = 36089 WHERE `entry` = 35572;
+UPDATE `creature_template` SET `difficulty_entry_1` = 36085 WHERE `entry` = 35569;
+UPDATE `creature_template` SET `difficulty_entry_1` = 36090 WHERE `entry` = 35571;
+UPDATE `creature_template` SET `difficulty_entry_1` = 36091 WHERE `entry` = 35570;
+UPDATE `creature_template` SET `difficulty_entry_1` = 36084 WHERE `entry` = 35617;
+UPDATE `creature_template` SET `difficulty_entry_1` = 36088 WHERE `entry` = 34705;
+UPDATE `creature_template` SET `difficulty_entry_1` = 36082 WHERE `entry` = 34702;
+UPDATE `creature_template` SET `difficulty_entry_1` = 36083 WHERE `entry` = 34701;
+UPDATE `creature_template` SET `difficulty_entry_1` = 36086 WHERE `entry` = 34657;
+UPDATE `creature_template` SET `difficulty_entry_1` = 36087 WHERE `entry` = 34703;
+UPDATE `creature_template` SET `difficulty_entry_1` = 35518 WHERE `entry` = 35119;
+UPDATE `creature_template` SET `difficulty_entry_1` = 35517 WHERE `entry` = 34928;
+UPDATE `creature_template` SET `difficulty_entry_1` = 35717 WHERE `entry` = 35590;
+UPDATE `creature` SET `phasemask`=2 WHERE `id`=20562;
+
+-- ----------------------
+--        SPAWNS
+-- ----------------------
+-- Spawns
+SET @SPAWN_GUID := 365000;
+DELETE FROM `creature` WHERE `map` = 650;
+INSERT INTO `creature` (`guid`, `id`, `map`, `spawnMask`, `phaseMask`, `modelid`, `equipment_id`, `position_x`, `position_y`, `position_z`, `orientation`, `spawntimesecs`, `spawndist`, `currentwaypoint`, `curhealth`, `curmana`, `MovementType`, `npcflag`, `unit_flags`, `dynamicflags`) VALUES
+(@SPAWN_GUID+000,36558,650,1,1,0,0,726.826,661.201,412.472,4.66003,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+001,36558,650,1,1,0,0,716.665,573.495,412.475,0.977384,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+002,36558,650,1,1,0,0,705.497,583.944,412.476,0.698132,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+003,36558,650,1,1,0,0,770.486,571.552,412.475,2.05949,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+004,36558,650,1,1,0,0,717.443,660.646,412.467,4.92183,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+005,36558,650,1,1,0,0,700.531,591.927,412.475,0.523599,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+006,36558,650,1,1,0,0,790.177,589.059,412.475,2.56563,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+007,36558,650,1,1,0,0,702.165,647.267,412.475,5.68977,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+008,36558,650,1,1,0,0,773.097,660.733,412.467,4.45059,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+009,36558,650,1,1,0,0,793.052,642.851,412.474,3.63029,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+010,36558,650,1,1,0,0,778.741,576.049,412.476,2.23402,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+011,35004,650,0,1,0,0,746.675,619.318,411.091,4.79268,300,0,0,10635,0,0,0,0,0),
+(@SPAWN_GUID+012,36558,650,1,1,0,0,788.016,650.788,412.475,3.80482,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+013,35644,650,1,1,0,0,704.943,651.33,412.475,5.60251,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+014,35644,650,1,1,0,0,774.898,573.736,412.475,2.14675,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+015,35644,650,1,1,0,0,699.943,643.37,412.474,5.77704,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+016,34871,650,0,1,0,0,795.968,651.859,435.421,3.6569,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+017,35644,650,1,1,0,0,793.009,592.667,412.475,2.6529,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+018,35644,650,1,1,0,0,702.967,587.649,412.475,0.610865,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+019,35644,650,1,1,0,0,768.255,661.606,412.47,4.55531,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+020,35644,650,1,1,0,0,720.569,571.285,412.475,1.06465,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+021,35644,650,1,1,0,0,787.439,584.969,412.476,2.47837,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+022,35644,650,1,1,0,0,722.363,660.745,412.468,4.83456,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+023,35644,650,1,1,0,0,790.49,646.533,412.474,3.71755,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+024,35644,650,1,1,0,0,777.564,660.3,412.467,4.34587,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+025,34990,650,0,1,0,0,807.814,618.058,435.395,3.0884,300,0,0,8367000,0,0,0,0,0),
+(@SPAWN_GUID+026,35016,650,1,1,0,0,702.274,638.76,412.47,0,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+027,35016,650,1,1,0,0,697.285,618.253,412.476,0,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+028,35016,650,1,1,0,0,714.486,581.722,412.476,0,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+029,35016,650,1,1,0,0,703.884,596.601,412.474,0,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+030,35016,650,1,1,0,0,712.413,653.931,412.474,0,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+031,34977,650,1,1,0,0,733.809,545.215,442.075,1.41372,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+032,34977,650,1,1,0,0,730.998,552.719,438.812,1.3439,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+033,34977,650,1,1,0,0,734.411,560.158,435.501,1.37881,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+034,34977,650,1,1,0,0,726.38,557.151,436.978,1.25664,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+035,34979,650,1,1,0,0,709.576,570.106,435.504,0.942478,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+036,34979,650,1,1,0,0,712.873,563.172,436.967,1.02974,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+037,34979,650,1,1,0,0,714.34,553.708,440.223,1.11701,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+038,34979,650,1,1,0,0,700.273,559.224,442.08,0.925025,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+039,34966,650,1,1,0,0,718.917,564.078,435.504,1.11701,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+040,34966,650,1,1,0,0,721.971,548.191,442.072,1.23918,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+041,34966,650,1,1,0,0,718.405,555.92,438.803,1.15192,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+042,34966,650,1,1,0,0,725.661,560.835,435.503,1.23918,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+043,34858,650,1,1,0,0,697.241,583.858,435.504,0.628319,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+044,34858,650,1,1,0,0,689.635,582.823,438.819,0.558505,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+045,34858,650,1,1,0,0,696.26,577.507,436.966,0.698132,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+046,34858,650,1,1,0,0,682.856,586.2,440.243,0.471239,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+047,34858,650,1,1,0,0,688.012,573.852,442.074,0.663225,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+048,34860,650,1,1,0,0,699.005,654.894,435.504,5.53269,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+049,34860,650,1,1,0,0,693.635,654.892,436.963,5.60251,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+050,34860,650,1,1,0,0,690.486,661.661,440.209,5.55015,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+051,34860,650,1,1,0,0,684.069,656.681,442.074,5.68977,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+052,34860,650,1,1,0,0,686.866,650.837,438.779,5.75959,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+053,34861,650,1,1,0,0,677.17,640.74,442.069,6.00393,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+054,34861,650,1,1,0,0,689.436,639.259,435.503,5.95157,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+055,34861,650,1,1,0,0,679.981,648.878,440.198,5.86431,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+056,34861,650,1,1,0,0,686.392,643.351,436.973,5.88176,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+057,34861,650,1,1,0,0,692.406,644.87,435.504,5.8294,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+058,34970,650,1,1,0,0,767.512,546.841,441.991,1.66197,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+059,34970,650,1,1,0,0,761.217,549.142,440.246,1.58825,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+060,34970,650,1,1,0,0,764.08,553.434,438.828,1.8675,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+061,34857,650,1,1,0,0,675.281,589.988,442.081,0.383972,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+062,34857,650,1,1,0,0,675.115,597.719,442.073,0.279253,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+064,34857,650,1,1,0,0,692.854,590.632,435.504,0.471239,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+065,34857,650,1,1,0,0,684.964,591.017,438.848,0.418879,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+066,34975,650,1,1,0,0,779.997,550.694,442.077,2.05949,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+067,34975,650,1,1,0,0,773.502,555.516,438.825,1.95477,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+068,34859,650,1,1,0,0,687.965,629.611,435.498,6.19592,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+069,34859,650,1,1,0,0,688.731,604.689,435.501,0.20944,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+070,34859,650,1,1,0,0,677.986,634.102,440.245,5.78437,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+071,34859,650,1,1,0,0,680.599,603.986,438.794,0.191986,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+072,34859,650,1,1,0,0,685.113,600.431,436.97,0.279253,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+073,34859,650,1,1,0,0,685.118,634.405,436.976,6.0912,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+074,34868,650,1,1,0,0,806.488,574.615,442.076,2.49582,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+075,34868,650,1,1,0,0,799.194,575.25,438.801,2.37365,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+076,34974,650,1,1,0,0,790.608,559.269,442.073,2.40855,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+077,34869,650,1,1,0,0,813.502,644.877,440.254,3.49066,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+078,34869,650,1,1,0,0,818.512,640.599,442.078,3.38594,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+079,34869,650,1,1,0,0,813.3,650.717,442.073,3.49066,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+080,34856,650,1,1,0,0,813.635,587.592,442.069,2.70526,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+081,34856,650,1,1,0,0,808.157,594.937,436.87,2.8495,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+082,34856,650,1,1,0,0,806.527,586.584,438.727,2.83379,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+083,34870,650,1,1,0,0,818.163,607.13,440.209,2.94961,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+084,34870,650,1,1,0,0,818.134,626.964,440.218,3.28122,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+085,34871,650,1,1,0,0,810.608,659.83,442.086,3.68265,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+086,34871,650,1,1,0,0,800.194,660.729,438.769,3.82227,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+087,34871,650,1,1,0,0,802.709,650.685,436.877,3.64668,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+088,34905,650,1,1,0,0,696.359,653.587,435.504,5.53252,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+089,34903,650,1,1,0,0,697.116,583.052,435.504,0.628319,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+090,34902,650,1,1,0,0,689.196,597,435.503,0.349066,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+091,34883,650,1,1,0,0,687.83,617.649,435.493,1.58825,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+092,34901,650,1,1,0,0,687.16,618.132,435.489,0,86400,0,0,1,0,0,0,0,0),
+(@SPAWN_GUID+093,34904,650,1,1,0,0,690.596,642,435.504,5.88176,86400,0,0,1,0,0,0,0,0),
+-- (@SPAWN_GUID+094,31144,650,0,1,0,0,796.773,604.543,412.385,2.58299,300,0,0,2,0,0,0,0,0),
+(@SPAWN_GUID+095,34996,650,0,1,0,546,746.725,556.492,435.396,1.59928,300,0,0,13945000,4258,0,0,0,0),
+(@SPAWN_GUID+096,35491,650,0,1,0,0,799.806,639.236,475.88,2.18738,300,0,0,189000,0,2,0,0,0),
+(@SPAWN_GUID+097,34992,650,0,1,0,0,809.178,624.409,435.395,3.0774,300,0,0,4505029,7981,0,0,0,0),
+(@SPAWN_GUID+098,34994,650,0,1,0,0,685.637,622.2,435.395,0.074604,300,0,0,7925544,4258,0,0,0,0),
+(@SPAWN_GUID+099,34995,650,0,1,0,0,686.255,615.367,435.399,0.074604,300,0,0,1394500,0,0,0,0,0),
+(@SPAWN_GUID+100,34871,650,0,1,0,0,808.958,652.464,440.151,3.6027,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+101,34871,650,0,1,0,0,802.134,656.474,438.717,3.78334,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+102,34869,650,0,1,0,0,811.348,640.844,438.7,3.3121,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+103,34869,650,0,1,0,0,807.653,636.377,436.902,3.3121,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+104,34869,650,0,1,0,0,802.876,642.818,435.421,3.3121,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+105,34869,650,0,1,0,0,809.194,646.673,438.7,3.70244,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+106,34870,650,0,1,0,0,813.093,631.476,438.704,3.17465,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+107,34870,650,0,1,0,0,808.383,631.705,436.9,3.17465,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+108,34870,650,0,1,0,0,815.127,636.5,440.169,3.27833,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+109,34870,650,0,1,0,0,818.937,632.312,441.991,3.37257,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+110,34870,650,0,1,0,0,809.167,602.84,436.874,2.78274,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+111,34870,650,0,1,0,0,812.745,602.889,438.704,2.81651,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+112,34870,650,0,1,0,0,819.104,598.436,441.996,2.92254,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+113,34856,650,0,1,0,0,814.28,596.223,440.175,2.90212,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+114,34868,650,0,1,0,0,799.128,581.376,436.896,2.61309,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+115,34868,650,0,1,0,0,806.628,580.52,440.148,2.61309,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+116,34868,650,0,1,0,0,793.731,579.421,435.421,2.61309,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+117,34868,650,0,1,0,0,799.549,587.703,435.421,2.48743,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+118,34970,650,0,1,0,0,760.024,559.473,435.418,1.61249,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+119,34970,650,0,1,0,0,751.913,544.129,441.99,1.74051,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+120,34970,650,0,1,0,0,766.899,557.863,436.915,1.66197,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+121,34975,650,0,1,0,0,774.213,563.449,435.421,2.09472,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+122,34975,650,0,1,0,0,781.049,563.972,436.893,2.04367,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+123,34975,650,0,1,0,0,781.712,556.65,440.159,2.12535,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+124,34974,650,0,1,0,0,781.8,568.648,435.421,2.20939,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+125,34974,650,0,1,0,0,788.423,568.361,436.881,2.20389,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+126,34974,650,0,1,0,0,787.929,563.884,438.695,2.18504,300,0,0,42,0,0,0,0,0),
+(@SPAWN_GUID+127,34857,650,1,1,0,0,689.623,598.045,435.503,0.331613,86400,0,0,1,0,0,0,0,0);
+UPDATE `creature` SET `spawnMask` = 3, `spawntimesecs` = 86400 WHERE `map` = 650;
+
+-- ----------------------
+--       MONTURAS
+-- ----------------------
+-- Vehicleid para Warhorse, esto no trae TDB11.44
+UPDATE `creature_template` SET `VehicleId`=486 WHERE `entry`=35644;
+-- Spells de monturas
+UPDATE `creature_template` SET `spell1` = 68505, `spell2` = 62575, `spell3` = 68282, `spell4` = 66482 WHERE `entry` IN (35644, 36558);
+-- Faccion de monturas
+UPDATE `creature_template` SET `faction_A` = 84, `faction_H` = 16 WHERE `entry` = 35644;
+UPDATE `creature_template` SET `faction_A` = 16, `faction_H` = 83 WHERE `entry` = 36558;
+-- Cero addons, las spells de escudo se aplican de otra forma
+DELETE FROM `creature_template_addon` WHERE `entry` IN (35644, 36558);
+
+-- ----------------------
+--     GAMEOBJECTS
+-- ----------------------
+-- Adios puerta anterior
+DELETE FROM `gameobject` WHERE `guid` = 150081;
+
+-- ----------------------
+--     MONTURAS NPCS
+-- ----------------------
+-- Monturas del evento Grand Faction Champions
+UPDATE `creature_template` SET `type_flags` = 2048, `ScriptName` = 'generic_vehicleAI_toc5' WHERE `entry` IN (35328, 35329, 35331, 35332, 35330, 35314, 35325, 35327, 35323, 35326);
+UPDATE `creature_template` SET `type_flags` = 2048,`mechanic_immune_mask` = 617299835 WHERE `entry` IN (35572, 35569, 35571, 35570, 35617, 34705, 34702, 34701, 34657, 34703);
+UPDATE `creature_template_addon` SET `auras` = LEFT(`auras`, 11) WHERE `entry` IN (35572, 35569, 35571, 35570, 35617, 34705, 34702, 34701, 34657, 34703);
+-- Monturas Hero
+CREATE TABLE `entry_temp` (`id` INT);
+INSERT INTO `entry_temp` SELECT `difficulty_entry_1` FROM `creature_template` WHERE `entry` IN (35572, 35569, 35571, 35570, 35617, 34705, 34702, 34701, 34657, 34703);
+UPDATE `creature_template` SET `type_flags` = 2048, `mechanic_immune_mask` = 617299835  WHERE `entry` IN (SELECT id FROM`entry_temp`);
+UPDATE `creature_template_addon` SET `auras` = LEFT(`auras`, 11) WHERE `entry` IN (SELECT id FROM`entry_temp`);
+DROP TABLE `entry_temp`;
+
+-- ----------------------
+--   EL CABALLERO NEGRO
+-- ----------------------
+-- Flags y configuracion de la montura
+UPDATE `creature_template` SET `unit_flags` = 64 WHERE `entry` IN (35451, 35490);
+DELETE FROM `vehicle_template_accessory` WHERE `entry` = 35491;
+INSERT INTO `vehicle_template_accessory` (`entry`, `accessory_entry`, `seat_id`, `minion`, `description`, `summontype`, `summontimer`) VALUES
+(35491,35451,0,0,'Trial of the Champion - Black Knight on his gryphon',6,30000);
+
+-- -----------------------
+-- MONTURA CABALLERO NEGRO
+-- -----------------------
+-- Black Knight Gryphon, faccion, unitflags y vehicleid basicamente
+UPDATE `creature_template` SET
+`faction_A`=35,
+`faction_H`=35,
+`mindmg`=0,
+`maxdmg`=0,
+`attackpower`=0,
+`dmg_multiplier`=0,
+`baseattacktime`=0,
+`unit_flags`=33554432,
+`dynamicflags`=0,
+`minrangedmg`=0,
+`maxrangedmg`=0,
+`rangedattackpower`=0,
+`VehicleId`=486 WHERE `entry`=35491;
+-- Asignacion de nombre de script
+UPDATE `creature_template` SET `flags_extra` = 2, `ScriptName` = 'npc_black_knight_skeletal_gryphon' WHERE `entry` = 35491;-- S
+-- Monta con spell
+DELETE FROM `npc_spellclick_spells` WHERE `npc_entry` = 35491;
+INSERT INTO `npc_spellclick_spells` (`npc_entry`, `spell_id`, `quest_start`, `quest_start_active`, `quest_end`, `cast_flags`, `aura_required`, `aura_forbidden`, `user_type`) VALUES
+(35491,46598,0,0,0,0,0,0,0);
+-- Especificando que vuela y que tiene waypoints para efecto de vuelo
+UPDATE `creature_template` SET `movementtype` = 2,`inhabittype` = 4 WHERE `entry` = 35491;
+UPDATE `creature` SET `movementtype` = 2 WHERE `id` = 35491;
+-- Waypoints (esto hay que retocar por si no queda bien)
+DELETE FROM `script_waypoint` WHERE `entry` = 35491;
+INSERT INTO `script_waypoint` (`entry`, `pointid`, `location_x`, `location_y`, `location_z`, `waittime`, `point_comment`) VALUES
+(35491,1,781.513,657.99,466.821,0,''),
+(35491,2,759.005,665.142,462.541,0,''),
+(35491,3,732.937,657.164,452.678,0,''),
+(35491,4,717.491,646.009,440.137,0,''),
+(35491,5,707.57,628.978,431.129,0,''),
+(35491,6,705.164,603.628,422.957,0,''),
+(35491,7,716.351,588.49,420.802,0,''),
+(35491,8,741.703,580.168,420.523,0,''),
+(35491,9,761.634,586.383,422.206,0,''),
+(35491,10,775.983,601.992,423.606,0,''),
+(35491,11,769.051,624.686,420.035,0,''),
+(35491,12,756.582,631.692,412.53,0,''),
+(35491,13,744.841,634.505,411.575,2000,''),
+(35491,14,759.005,665.142,462.541,0,''),
+(35491,15,747.127,813.51,460.707,0,'');
+
+-- ----------------------
+--   SOLDADOS ARGENTA
+-- ----------------------
+-- Configuraciones
+-- -- Argent Lightwielder
+UPDATE `creature_template` SET `modelid3` = 0 WHERE `entry` = 35309;
+UPDATE `creature_template` SET `minlevel` = 80, `maxlevel` = 80, `mindmg` = 420, `maxdmg` = 630, `attackpower` = 158, `mechanic_immune_mask` = 650854267 WHERE `entry` = 35310;
+-- -- Argent Monk
+UPDATE `creature_template` SET `modelid3` = 0 WHERE `entry` = 35305;
+UPDATE `creature_template` SET `minlevel` = 80, `maxlevel` = 80, `mindmg` = 420, `maxdmg` = 650, `attackpower` = 158, `mechanic_immune_mask` = 650854267 WHERE `entry` = 35306;
+-- -- Argent Priestess
+UPDATE `creature_template` SET `modelid3` = 0 WHERE `entry` = 35307;
+UPDATE `creature_template` SET `minlevel` = 80, `maxlevel` = 80, `mindmg` = 420, `maxdmg` = 630, `attackpower` = 158, `mechanic_immune_mask` = 650854267 WHERE `entry` = 35308;
+-- Script Names de los Soldados Argenta
+UPDATE creature_template SET ScriptName = 'npc_argent_monk' WHERE entry = 35305;
+UPDATE creature_template SET ScriptName = 'npc_argent_lightwielder' WHERE entry = 35309;
+UPDATE creature_template SET ScriptName = 'npc_argent_priest' WHERE entry = 35307;
+-- Inmunidades de los Soldados Argenta
+UPDATE `creature_template` SET `mechanic_immune_mask` = '650854267' WHERE `entry` IN (35305, 35309, 35307, 12488, 12439, 12448);
+-- Ajustes para los Soldados Argenta HERO
+UPDATE `creature_template` SET `Health_mod` = 29.4806 WHERE `entry`IN  (35306, 35308, 35310);
+UPDATE `creature_template` SET `Health_mod` = 51.8533 WHERE `entry` = 35490;
+UPDATE `creature_template` SET `Health_mod` = 16.4286 WHERE `entry` = 35451;
+-- Addons para los Soldados Argenta y varias auras
+DELETE FROM `creature_template_addon` WHERE `entry` IN (35305, 35306, 35307, 35308, 35309, 35310);
+INSERT INTO `creature_template_addon` (`entry`, `path_id`, `mount`, `bytes1`, `bytes2`, `emote`, `auras`) VALUES
+(35305, 0, 0, 0, 1, 27, '63501'),
+(35306, 0, 0, 0, 1, 27, '63501'),
+(35307, 0, 0, 0, 1, 375, '63501'),
+(35308, 0, 0, 0, 1, 375, '63501'),
+(35309, 0, 0, 0, 1, 375, '63501'),
+(35310, 0, 0, 0, 1, 375, '63501');
+DELETE FROM `creature_template_addon` WHERE (`entry` IN (35614, 35311));
+INSERT INTO `creature_template_addon` (`entry`, `path_id`, `mount`, `bytes1`, `bytes2`, `emote`, `auras`) VALUES
+(35614, 0, 0, 0, 0, 0, 67782), -- Desecration Stalker (Periodic Desecration)
+(35311, 0, 0, 0, 0, 0, 67196); -- Fountain of Light (Periodic Light rain)
+UPDATE `creature_template` SET `flags_extra` = 130 WHERE `entry` = 35614; -- Set Desecration Stalker as invisible passive trigger
+UPDATE `creature_template` SET `AIName` = 'SmartAI' WHERE `entry` = 35311; -- Set Light Fountain as passive
+DELETE FROM `smart_scripts` WHERE (`entryorguid`=35311 AND `source_type`=0);
+INSERT INTO `smart_scripts` (`entryorguid`, `source_type`, `id`, `link`, `event_type`, `event_phase_mask`, `event_chance`, `event_flags`, `event_param1`, `event_param2`, `event_param3`, `event_param4`, `action_type`, `action_param1`, `action_param2`, `action_param3`, `action_param4`, `action_param5`, `action_param6`, `target_type`, `target_param1`, `target_param2`, `target_param3`, `target_x`, `target_y`, `target_z`, `target_o`, `comment`) VALUES
+(35311, 0, 0, 0, 25, 0, 100, 7, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'Fountain of Light - Set passive');
+
+-- ----------------------
+--       MEMORIAS
+-- ----------------------
+-- Hero
+UPDATE `creature_template` SET `mindmg` = 330, `maxdmg` = 495, `attackpower` = 124, `baseattacktime` = 2000, `mechanic_immune_mask` = 617297499 WHERE `name` LIKE 'Memory of%(1)';
+-- Normal
+UPDATE `creature_template` SET `faction_A`=16, `faction_H`=16, `rank`=1, `minlevel`=82, `maxlevel`=82, `exp`=2 WHERE `name` LIKE 'Memory of %';
+
+-- ----------------------
+--    RESURRECCIONES
+-- ----------------------
+-- Aqui estan Arelas y Jaeren en el caballero negro
+UPDATE `creature_template` SET `mindmg` = 420, `maxdmg` = 630, `attackpower` = 158 WHERE `entry` = 35717;
+UPDATE `creature_template` SET `difficulty_entry_1` = 35546 WHERE `entry` = 35545;
+UPDATE `creature_template` SET `difficulty_entry_1` = 35568 WHERE `entry` = 35564;
+UPDATE `creature_template` SET `minlevel` = 80, `maxlevel` = 80, `mindmg` = 420, `maxdmg` = 630, `attackpower` = 158 WHERE `entry` IN (35568, 35546);
+UPDATE `creature_template` SET `minlevel` = 80, `maxlevel` = 80, `baseattacktime` = 2000, `faction_A` = 14, `faction_H` = 14 WHERE `entry` IN (35564, 35568, 35545, 35546, 35717, 35590);
+
+-- ----------------------
+--     EQUIPAMIENTOS
+-- ----------------------
+-- Memorias equip templates
+UPDATE `creature_template` SET `equipment_id` = 22 WHERE `entry` IN  (34942, 35531);
+UPDATE `creature_template` SET `equipment_id` = 1431 WHERE `entry` IN (35028, 35541);
+UPDATE `creature_template` SET `equipment_id` = 1178 WHERE `entry` IN (35030, 35530);
+UPDATE `creature_template` SET `equipment_id` = 1330 WHERE `entry` IN (35031, 35536);
+UPDATE `creature_template` SET `equipment_id` = 1808 WHERE `entry` IN (35036, 35543);
+UPDATE `creature_template` SET `equipment_id` = 1496 WHERE `entry` IN (35037, 35535);
+UPDATE `creature_template` SET `equipment_id` = 2216 WHERE `entry` IN (35042, 35533);
+UPDATE `creature_template` SET `equipment_id` = 714 WHERE `entry` IN (35045, 35534);
+UPDATE `creature_template` SET `equipment_id` = 271 WHERE `entry` IN (35049, 35529);
+-- Eadric
+UPDATE `creature_template` SET `equipment_id` = 833 WHERE `entry` IN (35119, 35518);
+-- Champions equip templates
+UPDATE `creature_template` SET `equipment_id` = 1892 WHERE `entry` IN (35572, 36089);
+UPDATE `creature_template` SET `equipment_id` = 1895 WHERE `entry` IN (35569, 36085);
+UPDATE `creature_template` SET `equipment_id` = 1899 WHERE `entry` IN (35571, 36090);
+UPDATE `creature_template` SET `equipment_id` = 1893 WHERE `entry` IN (35570, 36091);
+UPDATE `creature_template` SET `equipment_id` = 1894 WHERE `entry` IN (35617, 36084);
+
+UPDATE `creature_template` SET `equipment_id` = 1966 WHERE `entry` IN (34705, 36088);
+UPDATE `creature_template` SET `equipment_id` = 1993 WHERE `entry` IN (36082, 34702);
+UPDATE `creature_template` SET `equipment_id` = 1970 WHERE `entry` IN (36083, 34701);
+UPDATE `creature_template` SET `equipment_id` = 1969 WHERE `entry` IN (36086, 34657);
+UPDATE `creature_template` SET `equipment_id` = 1967 WHERE `entry` IN (34703, 36087);
+
+-- ----------------------
+--     INMUNIDADES
+-- ----------------------
+-- Los eadric, la chica y el caballero negro
+UPDATE `creature_template` SET `mechanic_immune_mask` = 617299835 WHERE `entry` IN (34928,35517,35119,35518,35451,35490);
+
+-- ----------------------
+--       SPELLS
+-- ----------------------
+DELETE FROM `spell_script_names` WHERE spell_id IN (66515, 66867, 67534, 67830, 66482);
+INSERT INTO `spell_script_names` VALUES
+(66867, 'spell_eadric_hammer_of_righteous'), -- Hammer can be picked by target if isn't under HoJ effect
+(66515, 'spell_paletress_shield'),           -- Reflect 25% of abosorbed damage
+(67534, 'spell_toc5_hex_mending'),           -- Hex of mending spell effect
+(67830, 'spell_toc5_ride_mount'),            -- Allow ride only if a Lance is equiped
+(66482, 'spell_toc5_defend');                -- Add visual shields depending on stack size
+-- Trigger en eadric
+DELETE FROM `spell_linked_spell` WHERE `spell_trigger` = 66905;
+INSERT INTO `spell_linked_spell` VALUES
+(66905, -66904, 0, 'Eadric Hammer of Righteous');  -- Remove the Hammer of Righteous spell after using it
+-- Condiciones en eventos en medio de la pelea
+DELETE FROM `conditions` WHERE SourceTypeOrReferenceId = 13 AND SourceEntry IN (66905, 67705, 67715, 66798);
+INSERT INTO `conditions` VALUES
+(13, 0, 66905, 0, 18, 1, 35119, 0, 0, 0, '', 'Eadric Hammer of Rigtheous'), -- Target Eadric with Hammer of Righteous
+(13, 0, 66798, 0, 18, 1, 35005, 0, 0, 0, '', 'The Black Kinght - Deaths Respite'),
+(13, 0, 66798, 0, 18, 1, 35004, 0, 0, 0, '', 'The Black Kinght - Deaths Respite'),
+(13, 0, 67705, 0, 18, 2, 35005, 0, 0, 0, '', 'The Black Kinght - Raise Arelas Brightstar'),
+(13, 0, 67715, 0, 18, 2, 35004, 0, 0, 0, '', 'The Black Kinght - Raise Arelas Brightstar');
+
+-- ----------------------
+--       TEXTOS
+-- ----------------------
+-- Aqui hubo que arreglar las tildes y demas
+SET @TIRION       := 34996;
+SET @THRALL       := 34994;
+SET @GARROSH      := 34995;
+SET @VARIAN       := 34990;
+SET @JAINA        := 34992;
+
+SET @EADRIC       := 35119;
+SET @PALETRESS    := 34928;
+SET @BLACK_KNIGHT := 35451;
+
+SET @SCRIPT_TEXTS_ID := -1999900;
+
+-- TEXTOS DEL PUBLICO Y VARIOS
+DELETE FROM `script_texts` WHERE `entry` <= @SCRIPT_TEXTS_ID AND `entry` >= @SCRIPT_TEXTS_ID-24;
+INSERT INTO `script_texts` (`npc_entry`,`entry`,`content_default`,`sound`,`type`,`language`,`emote`,`comment`) VALUES
+(0,@SCRIPT_TEXTS_ID-00, 'El publico anima a %s.',15882,2,0,1, 'ToC5 Cheers'),
+(0,@SCRIPT_TEXTS_ID-01, 'Los humanos de Ventormenta animan a %s.',13838,2,0,1, 'ToC5 Cheers'),
+(0,@SCRIPT_TEXTS_ID-02, 'Los orcos de Orgrimmar animan a %s.',13839,2,0,1, 'ToC5 Cheers'),
+(0,@SCRIPT_TEXTS_ID-03, 'Los enanos de Forjaz animan a %s.',13838,2,0,1, 'ToC5 Cheers'),
+(0,@SCRIPT_TEXTS_ID-05, 'Los no-muertos de Entranas animan a %s.',13839,2,0,1, 'ToC5 Cheers'),
+(0,@SCRIPT_TEXTS_ID-04, 'Los elfos la noche de Darnassus animan a %s.',13838,2,0,1, 'ToC5 Cheers'),
+(0,@SCRIPT_TEXTS_ID-06, 'Los tauren de Cima del Trueno animan a %s.',13839,2,0,1, 'ToC5 Cheers'),
+(0,@SCRIPT_TEXTS_ID-07, 'Los gnomos de Gnomeregan animan a %s.',13838,2,0,1, 'ToC5 Cheers'),
+(0,@SCRIPT_TEXTS_ID-08, 'Los trol de Sen\'jin animan a %s.',13839,2,0,1, 'ToC5 Cheers'),
+(0,@SCRIPT_TEXTS_ID-10, 'Los elfos de la sangre de Lunargenta animan a %s.',13839,2,0,1, 'ToC5 Cheers'),
+(0,@SCRIPT_TEXTS_ID-11, 'Los draenei de Exodar animan a %s.',13838,2,0,1, 'ToC5 Cheers'),
+(0,@SCRIPT_TEXTS_ID-12, '%s comienza a lanzar Pesadilla Lucida!',0,3,0,0, 'Paletress - Memory warning.'),
+(0,@SCRIPT_TEXTS_ID-13, '%s comienza a lanzar Martillo del Honrado sobre $N.',0,3,0,0, 'Eadric - Combat - Warning - Hammer'),
+(0,@SCRIPT_TEXTS_ID-20, '$N se ha alzado hasta el rango de $Gcampeon:campeona; en nuestro torneo. Nos orgullecemos de $Gpresentarlo:presentarla; hoy.',0,1,0,1, 'ToC5 Player presentation'),
+(0,@SCRIPT_TEXTS_ID-21, '$GUn:Una; $Gpoderoso:poderosa; $Gcampeon:campeona;, $Gun:una; $Gcapacitado:capacitada; $c, $gun:una; honorable $r. Presentamos a $N.',13838,1,0,1, 'ToC5 Player presentation'),
+(0,@SCRIPT_TEXTS_ID-22, 'Los campeones del torneo hablan muy bien de $Geste:esta; $c. Hoy presentamos a $N.',13838,1,0,1, 'ToC5 Player presentation'),
+(0,@SCRIPT_TEXTS_ID-23, '$GUno:Una; de $glos:las; mas $gfieros:fieras; $cs en el campo de batalla, presentamos a $N.',13838,1,0,1, 'ToC5 Player presentation'),
+(0,@SCRIPT_TEXTS_ID-24, 'Si aun no conoceis su nombre, estamos seguros de que lo hareis despues de este combate. Presentamos a $N.',13838,1,0,1, 'ToC5 Player presentation');
+
+-- INTROS
+DELETE FROM creature_text WHERE entry IN (35004, 35005, @TIRION, @THRALL, @GARROSH , @VARIAN , @JAINA, @EADRIC, @PALETRESS, @BLACK_KNIGHT);
+INSERT INTO creature_text (entry, groupid, id, TEXT, TYPE, LANGUAGE, probability, emote, duration, sound, COMMENT) VALUES
+-- -- Presentacion
+(35004,0,0,'Los Atracasol estan orgullosos de presentar a sus representantes en estas pruebas de combate.',14,0,100,1,0,0,'Announcer - Player Horde Champions - Intro'),
+(35005,0,0,'El Pacto de Plata esta encantado de presentar a sus luchadores para este evento, Alto Senor.',14,0,100,1,0,0,'Announcer - Player Alliance Champions - Intro'),
+(@TIRION,0,0,'Bienvenidos campeones. Hoy, ante los ojos de vuestros lideres y companeros os probareis como combatientes dignos.',14,0,100,1,0,0,'Tirion - Intro'),
+-- -- Horda
+(@THRALL,0,0,'Luchad con fuerza, Horda! Lok\'tar Ogar!',14,0,100,1,0,0,'Thrall - Intro'),
+(@GARROSH,0,0,'Por fin! Un combate digno de ser contemplado.',12,0,100,1,0,0,'Garrosh - Intro'),
+(@VARIAN,0,0,'No he venido hasta aqui para ver animales despezandose entre ellos sin ningun criterio, Tirion.',12,0,100,1,0,0,'Varian - Intro'),
+(@JAINA,0,0,'Son combatientes dignos, ya lo veras.',12,0,100,1,0,0,'Jaina - Intro'),
+-- -- Ali
+(@VARIAN,1,0,'No le veo la gracia a estos juegos, Tirion. Aun asi... Confio en que lo haran de una forma admirable.',12,0,100,1,0,0,'Thrall - Intro'),
+(@JAINA,1,0,'Por supuesto que lo haran.',12,0,100,1,0,0,'Garrosh - Intro'),
+(@GARROSH,1,0,'Admirable? Ja! Voy a disfrutar viendo a tus pequenos campeones fracasar, humano.',14,0,100,1,0,0,'Varian - Intro'),
+(@THRALL,1,0,'Garrosh, es suficiente.',12,0,100,1,0,0,'Jaina - Intro'),
+(@TIRION,1,0,'Primero os enfrentareis a tres de los Grandes Campeones del Torneo. Estos feroces contendientes han derrotado a todos los demas hasta alcanzar la maxima habilidad en la justa.',14,0,100,1,0,0,'Tirion - Intro'),
+
+-- CAMPEONES
+-- -- Horda
+(35004,1,0,'Aqui llega el pequeno pero mortal Ambrose Chisparrayo, Gran Campeon de Gnomeregan.',14,0,100,1,0,0,'Announcer - Alliance Champions - Intro Mage'),
+(35004,2,0,'Colosos, el enorme Gran Campeon de El Exodar, esta saliendo por la puerta.',14,0,100,1,0,0,'Announcer - Alliance Champions - Intro Shaman'),
+(35004,3,0,'Esta entrando en la arena la Gran Campeona de Darnassus, la habil centinela Jaelyne Unicanto.',14,0,100,1,0,0,'Announcer - Alliance Champions - Intro Hunter'),
+(35004,4,0,'Fuerte y orgulloso, aclamad al mariscal Jacob Alerius, el Gran Campeon de Ventormenta!',14,0,100,1,0,0,'Announcer - Alliance Champions - Intro Warrior'),
+(35004,5,0,'Hoy el poder de los enanos esta representado por la Gran Campeona de Forjaz, Lana Martillotenaz.',14,0,100,1,0,0,'Announcer - Alliance Champions - Intro Rouge'),
+-- -- Ali
+(35005,1,0,'Saliendo por la puerta Eressea Cantoalba, habil maga y Gran Campeona de Lunargenta!',14,0,100,1,0,0,'Announcer - Horde Champions - Intro Mage'),
+(35005,2,0,'En lo alto de su kodo, aqui esta el venerable Runok Ferocrin, Gran Campeon de Cima del Trueno!',14,0,100,1,0,0,'Announcer - Horde Champions - Intro Shaman'),
+(35005,3,0,'Entrando en la arena el enjuto pero peligroso Zul\'tore, Campeon de los Sen\'jin!',14,0,100,1,0,0,'Announcer - Horde Champions - Intro Hunter'),
+(35005,4,0,'Presentamos al Gran Campeon de Orgrimmar, Mokra el Trituracraneos!',14,0,100,1,0,0,'Announcer - Horde Champions - Intro Warrior'),
+(35005,5,0,'Representando la tenacidad de los Renegados, aqui esta el Gran Campeon de Entranas, Mortacechador Visceri!',14,0,100,1,0,0,'Announcer - Horde Champions - Intro Rouge'),
+
+-- ARGENTAS
+(@TIRION,2,0,'Buen combate! Vuestro proximo reto viene de los mismisimos cargos de la Cruzada. Sereis puestos a prueba contra sus considerables habilidades.',14,0,100,1,0,0,'Tirion - Intro'),
+-- -- Eadric
+(35004,11,0,'Entrando en la arena, tenemos a un paladin que no es un extrano para los campos de batalla, ni los Campos del Torneo. El gran campeon de la Cruzada Argenta, Eadric el Puro!',14,0,100,1,0,0,'Announcer - Eadric - Intro'),
+(35005,11,0,'Entrando en la arena, tenemos a un paladin que no es un extrano para los campos de batalla, ni los Campos del Torneo. El gran campeon de la Cruzada Argenta, Eadric el Puro!',14,0,100,1,0,0,'Announcer - Eadric - Intro'),
+(@EADRIC,10,0,'Aceptais el reto? No hay vuelta atras!',12,0,100,1,0,16134,'Eadric - Intro'),
+-- -- Paletress
+(35004,12,0,'La siguiente combatiente no tiene rival alguno en su pasion al apoyar a la Luz. Les entrego a la confesora Argenta Cabelloclaro!',14,0,100,1,0,0,'Announcer - Paletress - Intro'),
+(35005,12,0,'La siguiente combatiente no tiene rival alguno en su pasion al apoyar a la Luz. Les entrego a la confesora Argenta Cabelloclaro!',14,0,100,1,0,0,'Announcer - Paletress - Intro'),
+(@PALETRESS,10,0,'Gracias buen heraldo. Tus palabras son muy amables.',12,0,100,1,0,16245,'Paletress - Intro'),
+(@PALETRESS,11,0,'Que la luz me de fuerzas para ser un reto digno.',12,0,100,1,0,16246,'Paletress - Intro'),
+-- -- Tirion
+(@TIRION,3,0,'Podeis comenzar!',14,0,100,1,0,0,'Tirion - Intro'),
+
+-- CABALLERO NEGRO
+(@TIRION,4,0,'Bien hecho. Habeis probado vuestra valia hoy...',14,0,100,1,0,0,'Tirion - Intro'),
+(35004,13,0,'Que es eso que hay cerca de las vigas?',12,0,100,1,0,0,'Announcer - Black Knight - Intro'),
+(35005,13,0,'Que es eso que hay cerca de las vigas?',12,0,100,1,0,0,'Announcer - Black Knight - Intro'),
+(@BLACK_KNIGHT,10,0,'Has estropeado mi gran entrada, rata.',12,0,100,1,0,16256,'Black Knight - Intro'),
+(@TIRION,5,0,'Que significa esto?',14,0,100,1,0,0,'Tirion - Intro'),
+(@BLACK_KNIGHT,11,0,'Realmente pensabas que derrotarias a un agente del Rey Exanime en los campos de tu patetico torneo?',12,0,100,1,0,16257,'Black Knight - Intro'),
+(@BLACK_KNIGHT,12,0,'He venido a terminar mi cometido.',12,0,100,1,0,16258,'Black Knight - Intro'),
+(@GARROSH,10,0,'Hacedlo picadillo!',14,0,100,1,0,0,'Garrosh - Black Knight - Intro'),
+(@VARIAN,10,0,'No os quedeis ahi mirando; matadlo!',14,0,100,1,0,0,'Varian - Black Knight - Intro'),
+
+-- TEXTOS EN COMBATES
+-- -- Eadric
+(@EADRIC,1,0,'Preparaos!',14,0,100,0,0,16135,'Eadric - Combat - Aggro'),
+(@EADRIC,2,0,'Martillo del honrado!',14,0,100,0,0,16136,'Eadric - Combat - Hammer'),
+(@EADRIC,3,0,'Tu! Tienes que practicar mas!',14,0,100,0,0,16137,'Eadric - Combat - Slay 1'),
+(@EADRIC,3,1,'No! No! Y otra vez no! No es suficiente!',14,0,100,0,0,16138,'Eadric - Combat - Slay 2'),
+(@EADRIC,4,0,'Me rindo! Lo admito. Un trabajo excelente. Puedo escaparme ya?',14,0,100,0,0,16139,'Eadric - Combat - Death'),
+(@EADRIC,5,0,'%s comienza a irradiar luz. Cubrios los ojos!',41,0,100,0,0,0,'Eadric - Combat - Warning - Radiance'),
+-- -- Paletress
+(@PALETRESS,1,0,'Bien entonces. Comencemos.',14,0,100,0,0,16247,'Paletress - Combat - Aggro'),
+(@PALETRESS,2,0,'Aprovecha este tiempo para pensar en tus hazanas.',14,0,100,0,0,16248,'Paletress - Combat - Summon Memory'),
+(@PALETRESS,3,0,'Descansa.',14,0,100,0,0,16250,'Paletress - Combat - Slay 1'),
+(@PALETRESS,3,1,'Ve en paz.',14,0,100,0,0,16251,'Paletress - Combat - Slay 2'),
+(@PALETRESS,4,0,'Un trabajo excelente!',14,0,100,0,0,16252,'Paletress - Combat - Death'),
+(@PALETRESS,5,0,'Incluso el recuerdo mas oscuro se desvanece al afrontarlo.',14,0,100,0,0,16249,'Paletress - Combat - Memory dies'),
+-- -- Black Knight
+(@BLACK_KNIGHT,1,0,'Esta farsa acaba aqui!',14,0,100,0,0,16259,'Black Knight - Combat - Aggro'),
+(@BLACK_KNIGHT,2,0,'Patetico.',14,0,100,0,0,16260,'Black Knight - Combat - Slay 1'),
+(@BLACK_KNIGHT,2,1,'Que desperdicio!',14,0,100,0,0,16261,'Black Knight - Combat - Slay 2'),
+(@BLACK_KNIGHT,3,0,'Me estorbaba esa carne putrefacta!',14,0,100,0,0,16262,'Black Knight - Combat - Skeleton Res'),
+(@BLACK_KNIGHT,4,0,'No necesito huesos para vencerte.',14,0,100,0,0,16263,'Black Knight - Combat - Ghost Res'),
+(@BLACK_KNIGHT,5,0,'No! No debo fallar... otra vez...',14,0,100,0,0,16264,'Black Knight - Combat - Death');
+
+-- ----------------------
+--        LOGROS
+-- ----------------------
+-- Achievements
+DELETE FROM achievement_criteria_data WHERE criteria_id IN (11863, 11420, 12439, 11858);
+DELETE FROM achievement_criteria_data WHERE criteria_id BETWEEN 12298 AND 12306;
+DELETE FROM achievement_criteria_data WHERE criteria_id BETWEEN 12310 AND 12324;
+DELETE FROM achievement_criteria_data WHERE criteria_id BETWEEN 11904 AND 11927;
+INSERT INTO `achievement_criteria_data` VALUES
+-- Champion achievements (Normal)
+(11420, 18, 0, 0, ''),
+(12298, 18, 0, 0, ''),
+(12299, 18, 0, 0, ''),
+(12300, 18, 0, 0, ''),
+(12301, 18, 0, 0, ''),
+(12302, 18, 0, 0, ''),
+(12303, 18, 0, 0, ''),
+(12304, 18, 0, 0, ''),
+(12305, 18, 0, 0, ''),
+(12306, 18, 0, 0, ''),
+-- Champion achievements (Hero)
+(12310, 18, 0, 0, ''),
+(12311, 18, 0, 0, ''),
+(12312, 18, 0, 0, ''),
+(12313, 18, 0, 0, ''),
+(12314, 18, 0, 0, ''),
+(12318, 18, 0, 0, ''),
+(12319, 18, 0, 0, ''),
+(12320, 18, 0, 0, ''),
+(12321, 18, 0, 0, ''),
+(12322, 18, 0, 0, ''),
+-- Memories achievment
+(11863, 18, 0, 0, ''),
+(11904, 18, 0, 0, ''),
+(11905, 18, 0, 0, ''),
+(11906, 18, 0, 0, ''),
+(11907, 18, 0, 0, ''),
+(11908, 18, 0, 0, ''),
+(11909, 18, 0, 0, ''),
+(11910, 18, 0, 0, ''),
+(11911, 18, 0, 0, ''),
+(11912, 18, 0, 0, ''),
+(11913, 18, 0, 0, ''),
+(11914, 18, 0, 0, ''),
+(11915, 18, 0, 0, ''),
+(11916, 18, 0, 0, ''),
+(11917, 18, 0, 0, ''),
+(11918, 18, 0, 0, ''),
+(11919, 18, 0, 0, ''),
+(11920, 18, 0, 0, ''),
+(11921, 18, 0, 0, ''),
+(11922, 18, 0, 0, ''),
+(11923, 18, 0, 0, ''),
+(11924, 18, 0, 0, ''),
+(11925, 18, 0, 0, ''),
+(11926, 18, 0, 0, ''),
+(11927, 18, 0, 0, ''),
+-- Champion achievements (Hero)
+(12310, 12, 1, 0, ''),
+(12311, 12, 1, 0, ''),
+(12312, 12, 1, 0, ''),
+(12313, 12, 1, 0, ''),
+(12314, 12, 1, 0, ''),
+(12315, 12, 1, 0, ''),
+(12316, 12, 1, 0, ''),
+(12317, 12, 1, 0, ''),
+(12318, 12, 1, 0, ''),
+(12319, 12, 1, 0, ''),
+(12320, 12, 1, 0, ''),
+(12321, 12, 1, 0, ''),
+(12322, 12, 1, 0, ''),
+(12323, 12, 1, 0, ''),
+(12324, 12, 1, 0, ''),
+(12439, 12, 1, 0, ''),
+-- Faceroller achievement
+(11858, 12, 1, 0, ''),
+-- Memories achievement
+(11863, 12, 1, 0, ''),
+(11904, 12, 1, 0, ''),
+(11905, 12, 1, 0, ''),
+(11906, 12, 1, 0, ''),
+(11907, 12, 1, 0, ''),
+(11908, 12, 1, 0, ''),
+(11909, 12, 1, 0, ''),
+(11910, 12, 1, 0, ''),
+(11911, 12, 1, 0, ''),
+(11912, 12, 1, 0, ''),
+(11913, 12, 1, 0, ''),
+(11914, 12, 1, 0, ''),
+(11915, 12, 1, 0, ''),
+(11916, 12, 1, 0, ''),
+(11917, 12, 1, 0, ''),
+(11918, 12, 1, 0, ''),
+(11919, 12, 1, 0, ''),
+(11920, 12, 1, 0, ''),
+(11921, 12, 1, 0, ''),
+(11922, 12, 1, 0, ''),
+(11923, 12, 1, 0, ''),
+(11924, 12, 1, 0, ''),
+(11925, 12, 1, 0, ''),
+(11926, 12, 1, 0, ''),
+(11927, 12, 1, 0, '');
+
+-- ----------------------
+--       AJUSTES
+-- ----------------------
+-- Basicamente dano y armor
+-- Tial of the Champion (Normal)
+UPDATE `creature_template`
+    SET `dmg_multiplier` = CASE `entry`
+        -- Faction Grand Champions
+        WHEN 35572 THEN 11.2 -- Grand Champion Warrior
+        WHEN 34705 THEN 11.2
+        WHEN 35569 THEN 10.2 -- Grand Champion Mage
+        WHEN 34702 THEN 10.2
+        WHEN 34701 THEN 10.2 -- Grand Champion Shaman
+        WHEN 35571 THEN 10.2
+        WHEN 35570 THEN 10.2 -- Grand Champion Hunter
+        WHEN 34657 THEN 10.2
+        WHEN 35617 THEN 10.2 -- Grand Champion Rouge
+        WHEN 34703 THEN 10.2
+        -- Argent Challenge
+        WHEN 35305 THEN 8    -- Argent Monk
+        WHEN 35307 THEN 5.5  -- Argent Priestess
+        WHEN 35309 THEN 8.4  -- Argent Lightwielder
+        WHEN 35119 THEN 14.5 -- Eadric the Pure
+        WHEN 34928 THEN 14.5 -- Argent Confessor Paletress
+        -- Black Knight Encounter
+        WHEN 35564 THEN 1.4  -- Risen Arelas Brightstar
+        WHEN 35545 THEN 1.4  -- Risen Jaeren Sunsworn
+        WHEN 35590 THEN 1.5  -- Risen Champion
+        WHEN 35451 THEN 11.8 -- Black Knight
+    END,
+    `Armor_mod` = CASE `entry`
+        -- Faction Grand Champions
+        WHEN 35572 THEN 1    -- Grand Champion Warrior
+        WHEN 34705 THEN 1
+        WHEN 35569 THEN 1    -- Grand Champion Mage
+        WHEN 34702 THEN 1
+        WHEN 34701 THEN 1    -- Grand Champion Shaman
+        WHEN 35571 THEN 1
+        WHEN 35570 THEN 1    -- Grand Champion Hunter
+        WHEN 34657 THEN 1
+        WHEN 35617 THEN 1    -- Grand Champion Rouge
+        WHEN 34703 THEN 1
+        -- Argent Challenge
+        WHEN 35305 THEN 1    -- Argent Monk
+        WHEN 35307 THEN 1    -- Argent Priestess
+        WHEN 35309 THEN 1    -- Argent Lightwielder
+        WHEN 35119 THEN 1    -- Eadric the Pure
+        WHEN 34928 THEN 1    -- Argent Confessor Paletress
+        -- Black Knight Encounter
+        WHEN 35564 THEN 1    -- Risen Arelas Brightstar
+        WHEN 35545 THEN 1    -- Risen Jaeren Sunsworn
+        WHEN 35590 THEN 1    -- Risen Champion
+        WHEN 35451 THEN 1    -- Black Knight
+    END
+WHERE `entry` IN (35572, 34705, 35569, 34702, 34701, 35571, 35570, 34657, 35617, 34703, 35305, 35307, 35309, 35119, 34928, 35564, 35545, 35590, 35451);
+
+-- Tial of the Champion (Heroic)
+UPDATE `creature_template`
+    SET `dmg_multiplier` = CASE `entry`
+    -- Heroic difficult
+        -- Faction Grand Champions
+        WHEN 36088 THEN 13   -- Grand Champion Warrior
+        WHEN 36089 THEN 13
+        WHEN 36085 THEN 13   -- Grand Champion Mage
+        WHEN 36082 THEN 13
+        WHEN 36083 THEN 13   -- Grand Champon Shaman
+        WHEN 36090 THEN 13
+        WHEN 36091 THEN 13   -- Grand Champion Hunter
+        WHEN 36086 THEN 13
+        WHEN 36084 THEN 13   -- Grand Champion Rouge
+        WHEN 36087 THEN 13
+        -- Argent Challenge
+        WHEN 35306 THEN 16   -- Argent Monk
+        WHEN 35308 THEN 11   -- Argent Priestess
+        WHEN 35310 THEN 16.8 -- Argent Lightwielder
+        WHEN 35518 THEN 13   -- Eadric the Pure
+        WHEN 35517 THEN 13   -- Argent Confessor Paletress
+        -- Black Knight Encounter
+        WHEN 35568 THEN 3    -- Risen Arelas Brightstar
+        WHEN 35546 THEN 3    -- Risen Jaeren Sunsworn
+        WHEN 35717 THEN 3    -- Risen Champion
+        WHEN 35490 THEN 17.6 -- Black Knight (Heroic)
+    END,
+    `Armor_mod` = CASE `entry`
+        -- Faction Grand Champions
+        WHEN 36088 THEN 1    -- Grand Champion Warrior
+        WHEN 36089 THEN 1
+        WHEN 36085 THEN 1    -- Grand Champion Mage
+        WHEN 36082 THEN 1
+        WHEN 36083 THEN 1    -- Grand Champon Shaman
+        WHEN 36090 THEN 1
+        WHEN 36091 THEN 1    -- Grand Champion Hunter
+        WHEN 36086 THEN 1
+        WHEN 36084 THEN 1    -- Grand Champion Rouge
+        WHEN 36087 THEN 1
+        -- Argent Challenge
+        WHEN 35306 THEN 1    -- Argent Monk
+        WHEN 35308 THEN 1    -- Argent Priestess
+        WHEN 35310 THEN 1    -- Argent Lightwielder
+        WHEN 35518 THEN 1    -- Eadric the Pure
+        WHEN 35517 THEN 1    -- Argent Confessor Paletress
+        -- Black Knight Encounter
+        WHEN 35568 THEN 1    -- Risen Arelas Brightstar
+        WHEN 35546 THEN 1    -- Risen Jaeren Sunsworn
+        WHEN 35717 THEN 1    -- Risen Champion
+        WHEN 35490 THEN 1    -- Black Knight (Heroic)
+    END
+WHERE `entry` IN (36088, 36089, 36085, 36082, 36083, 36090, 36091, 36086, 36084, 36087, 35306, 35308, 35310, 35518, 35517, 35568, 35546, 35717, 35490);
\ No newline at end of file
diff --git a/src/server/game/Spells/SpellEffects.cpp b/src/server/game/Spells/SpellEffects.cpp
index c3a52e7..7628939 100755
--- a/src/server/game/Spells/SpellEffects.cpp
+++ b/src/server/game/Spells/SpellEffects.cpp
@@ -4561,6 +4561,68 @@ void Spell::EffectScriptEffect(SpellEffIndex effIndex)
                 case 26465:
                     unitTarget->RemoveAuraFromStack(26464);
                     return;
+                // Shield-Breaker - Argent Tournament
+                case 64595:
+                    if(m_caster->GetOwner())
+                        m_caster->GetOwner()->CastSpell(unitTarget, 64590, true);
+                    else
+                        m_caster->CastSpell(unitTarget, 64590, true);
+                        return;
+                case 62575:
+                {
+                    if(m_caster->GetOwner())
+                        m_caster->GetOwner()->CastSpell(unitTarget, 62626, true);
+                    else
+                        m_caster->CastSpell(unitTarget, 62626, true);
+                        return;
+                }
+                // Charge - Argent Tournament
+                case 62960:
+                {
+                    if (!unitTarget)
+                        return;
+                    m_caster->CastSpell(unitTarget, 62563, true);
+                    m_caster->CastSpell(unitTarget, 68321, true);
+                    return;
+                }
+                // Charge - Argent Tournament
+                case 68282:
+                {
+                    if (!unitTarget)
+                        return;
+                    m_caster->CastSpell(unitTarget, 68284, true);
+                }
+                // Necrocution - Argent Tournament
+                case 63233:
+                // Sundering Thrust - Argent Tournament
+                case 63825:
+                // Counter attack - Argent Tournament
+                case 62709:
+                // Shield-Breaker - Argent Tournament
+                case 64590:
+                case 65147:
+                case 62626:
+                    if(!unitTarget)
+                        return;
+                    if (unitTarget->GetAura(64100))
+                        unitTarget->RemoveAuraFromStack(64100);
+                // Charge - Argent Tournament
+                case 63010:
+                case 63003:
+                case 68321:
+                {
+                    if(!unitTarget)
+                        return;
+                    if (unitTarget->GetAura(62719))
+                        unitTarget->RemoveAuraFromStack(62719);
+
+                    if (unitTarget->GetAura(62552))
+                        unitTarget->RemoveAuraFromStack(62552);
+
+                    if(Aura* defend = unitTarget->GetAura(66482))
+                        defend->ModStackAmount(-1);
+                    return;
+                }
                 // Shadow Flame (All script effects, not just end ones to prevent player from dodging the last triggered spell)
                 case 22539:
                 case 22972:
diff --git a/src/server/game/Texts/CreatureTextMgr.cpp b/src/server/game/Texts/CreatureTextMgr.cpp
index e5a1269..b41aba5 100755
--- a/src/server/game/Texts/CreatureTextMgr.cpp
+++ b/src/server/game/Texts/CreatureTextMgr.cpp
@@ -178,6 +178,10 @@ uint32 CreatureTextMgr::SendChat(Creature* source, uint8 textGroup, uint64 whisp
     Language finalLang = (language == LANG_ADDON) ? (*iter).lang : language;
     uint32 finalSound = sound ? sound : (*iter).sound;
 
+    if (Map* map = source->GetMap())
+        if (map->IsDungeon())
+            range = TEXT_RANGE_ZONE;
+
     if (finalSound)
         SendSound(source, finalSound, finalType, whisperGuid, range, team, gmOnly);
 
diff --git a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_argent_challenge.cpp b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_argent_challenge.cpp
index d5695a0..f028dc1 100644
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_argent_challenge.cpp
+++ b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_argent_challenge.cpp
@@ -15,10 +15,11 @@
  * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
+// Reordenada, trinity codestyle y limpieza de CRLF por Eilo
 /* ScriptData
 SDName: Argent Challenge Encounter.
-SD%Complete: 50 %
-SDComment: AI for Argent Soldiers are not implemented. AI from bosses need more improvements.
+SD%Complete: 80%
+SDComment: Hay que mirar bien las habilidades de las memorias y mejorarlas
 SDCategory: Trial of the Champion
 EndScriptData */
 
@@ -26,14 +27,38 @@ EndScriptData */
 #include "trial_of_the_champion.h"
 #include "ScriptedEscortAI.h"
 
-enum eSpells
+enum Spells
 {
+    // Argent Soldiers
+    SPELL_KNEE                  = 68442,
+    // Monk
+    SPELL_DIVINE_SHIELD         = 67251,
+    SPELL_FINAL_MEDITATION      = 67255,
+    SPELL_FLURRY_OF_BLOWS       = 67233,
+    SPELL_PUMMEL                = 67235,
+    // Lightwielder
+    SPELL_BLAZING_LIGHT         = 67247,
+    SPELL_CLEAVE                = 15284,
+    SPELL_UNBALANCING_STRIKE    = 67237,
+    // Priest
+    SPELL_HOLY_SMITE            = 36176,
+    SPELL_HOLY_SMITE_H          = 67289,
+    SPELL_SHADOW_WORD_PAIN      = 34941,
+    SPELL_SHADOW_WORD_PAIN_H    = 34942,
+    SPELL_MIND_CONTROL          = 67229,
+    SPELL_FOUNTAIN_OF_LIGHT     = 67194,
+
     //Eadric
-    SPELL_EADRIC_ACHIEVEMENT    = 68197,
+    SPELL_EADRIC_ACHIEVEMENT    = 68197, // Faceroller achievement
     SPELL_HAMMER_JUSTICE        = 66863,
     SPELL_HAMMER_RIGHTEOUS      = 66867,
     SPELL_RADIANCE              = 66935,
     SPELL_VENGEANCE             = 66865,
+    SPELL_VENGANCE_AURA         = 66889,
+    // Necessary for the achievement
+    SPELL_HAMMER_RIGHTEOUS_P    = 66904, // Aura on player, changes to a stance with the spell
+    SPELL_HAMMER_RIGHTEOUS_RET  = 66905, // Casted by player to Eadric
+    SPELL_HAMMER_JUSTICE_STUN   = 66940,
 
     //Paletress
     SPELL_SMITE                 = 66536,
@@ -48,6 +73,7 @@ enum eSpells
     SPELL_SUMMON_MEMORY         = 66545,
 
     //Memory
+    SPELL_SHADOW_FORM           = 34429, // THIS IS NOT CORRECT!
     SPELL_OLD_WOUNDS            = 66620,
     SPELL_OLD_WOUNDS_H          = 67679,
     SPELL_SHADOWS_PAST          = 66619,
@@ -56,6 +82,21 @@ enum eSpells
     SPELL_WAKING_NIGHTMARE_H    = 67677
 };
 
+enum Says
+{
+    SAY_COMMON_AGGRO                = 1,
+    SAY_COMMON_KILL                 = 3,
+    SAY_COMMON_DEATH                = 4,
+
+    SAY_EADRIC_HAMMER               = 2,
+    SAY_EADRIC_RADIANCE_WARNING     = 5,
+    SAY_EADRIC_HAMMER_WARNING       = -1999913,
+
+    SAY_PALETRESS_SUMMON_MEMORY     = 2,
+    SAY_PALETRESS_MEMORY_DIES       = 5,
+    SAY_PALETRESS_NIGHTMARE_WARNING = -1999912,  // Convert to script_texts
+};
+
 class OrientationCheck : public std::unary_function<Unit*, bool>
 {
     public:
@@ -94,72 +135,145 @@ class spell_eadric_radiance : public SpellScriptLoader
         }
 };
 
+class spell_eadric_hammer_of_righteous : public SpellScriptLoader
+{
+    public:
+        spell_eadric_hammer_of_righteous() : SpellScriptLoader("spell_eadric_hammer_of_righteous") {}
+
+        class spell_eadric_hammer_of_righteousSpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_eadric_hammer_of_righteousSpellScript)
+
+            void HandleBeforeHit()
+            {
+                Unit* caster = GetCaster();
+                Unit* target = GetTargetUnit();
+
+                if(!caster || !target)
+                    return;
+
+                Aura* hammerJustice = target->GetAura(SPELL_HAMMER_JUSTICE_STUN);
+
+                // Target isn't affected by HoJ so is able to pickup the Hammer
+                if(!hammerJustice)
+                {
+                    caster->CastSpell(target, SPELL_HAMMER_RIGHTEOUS_P);
+                    PreventHitDamage();
+                }
+            }
+
+            void Register()
+            {
+                BeforeHit += SpellHitFn(spell_eadric_hammer_of_righteousSpellScript::HandleBeforeHit);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_eadric_hammer_of_righteousSpellScript();
+        }
+};
+
 class boss_eadric : public CreatureScript
 {
 public:
     boss_eadric() : CreatureScript("boss_eadric") { }
     struct boss_eadricAI : public ScriptedAI
     {
-        boss_eadricAI(Creature* creature) : ScriptedAI(creature)
+        boss_eadricAI(Creature* creature) : ScriptedAI(creature) { }
+
+        uint32 venganceTimer;
+        uint32 radianceTimer;
+        uint32 hammerJusticeTimer;
+
+        bool defeated;
+
+        void Reset()
         {
-            instance = creature->GetInstanceScript();
-            creature->SetReactState(REACT_PASSIVE);
-            creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            venganceTimer = 10000;
+            radianceTimer = 16000;
+            hammerJusticeTimer = 25000;
+
+            defeated = false;
         }
 
-        InstanceScript* instance;
+        void SpellHit(Unit* /*caster*/, const SpellInfo *spell)
+        {
+            // Faceroller achievement
+            if(IsHeroic())
+                if(spell->Id == SPELL_HAMMER_RIGHTEOUS_RET)
+                    if(me->GetHealth() <= (uint32)spell->Effects[0].BasePoints)
+                        if(InstanceScript* instance = me->GetInstanceScript())
+                            instance->DoUpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, SPELL_EADRIC_ACHIEVEMENT);
+        }
 
-        uint32 uiVenganceTimer;
-        uint32 uiRadianceTimer;
-        uint32 uiHammerJusticeTimer;
-        uint32 uiResetTimer;
+        void EnterCombat(Unit* /*attacker*/)
+        {
+            Talk(SAY_COMMON_AGGRO);
 
-        bool bDone;
+            if(InstanceScript* instance = me->GetInstanceScript())
+                if(instance->GetData(BOSS_ARGENT_CHALLENGE_E) != IN_PROGRESS)
+                    instance->SetData(BOSS_ARGENT_CHALLENGE_E, IN_PROGRESS);
+        }
 
-        void Reset()
+        void JustReachedHome()
         {
-            uiVenganceTimer = 10000;
-            uiRadianceTimer = 16000;
-            uiHammerJusticeTimer = 25000;
-            uiResetTimer = 5000;
+            if(InstanceScript* instance = me->GetInstanceScript())
+                if(instance->GetData(BOSS_ARGENT_CHALLENGE_E) == IN_PROGRESS)
+                    instance->SetData(BOSS_ARGENT_CHALLENGE_E, FAIL);
+        }
 
-            bDone = false;
+        void KilledUnit(Unit* /*target*/)
+        {
+            Talk(SAY_COMMON_KILL);
         }
 
         void DamageTaken(Unit* /*done_by*/, uint32 &damage)
         {
+            if(defeated)
+            {
+                damage = 0;
+                return;
+            }
+
+            // Prevent damage from finishing hit and mark creature as defeated
             if (damage >= me->GetHealth())
             {
                 damage = 0;
-                EnterEvadeMode();
-                me->setFaction(35);
-                bDone = true;
+                defeated = true;
+                me->SetUnitMovementFlags(MOVEMENTFLAG_WALKING);
+                me->GetMotionMaster()->MovePoint(1, me->GetHomePosition());
+                me->SetTarget(0);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                Talk(SAY_COMMON_DEATH);
+                BindPlayersToInstance(me);
             }
         }
 
-        void MovementInform(uint32 MovementType, uint32 /*Data*/)
+        void MovementInform(uint32 type, uint32 id)
         {
-            if (MovementType != POINT_MOTION_TYPE)
-                return;
+            if(type == POINT_MOTION_TYPE && id == 1)
+                me->DespawnOrUnsummon(0);
+        }
 
-            if (instance)
-                instance->SetData(BOSS_ARGENT_CHALLENGE_E, DONE);
+        uint32 GetData(uint32 type)
+        {
+            // Used by Announcer on periodic check of the bosses state
+            if(type == DATA_CHAMPION_DEFEATED)
+                return defeated ? 1 : 0;
 
-            me->DisappearAndDie();
+            return 0;
         }
 
-        void UpdateAI(const uint32 uiDiff)
+        void UpdateAI(const uint32 diff)
         {
-            if (bDone && uiResetTimer <= uiDiff)
-            {
-                me->GetMotionMaster()->MovePoint(0, 746.87f, 665.87f, 411.75f);
-                bDone = false;
-            } else uiResetTimer -= uiDiff;
-
             if (!UpdateVictim())
                 return;
 
-            if (uiHammerJusticeTimer <= uiDiff)
+            if(defeated || me->HasUnitState(UNIT_STATE_CASTING))
+                return;
+
+            if (hammerJusticeTimer <= diff)
             {
                 me->InterruptNonMeleeSpells(true);
 
@@ -167,28 +281,39 @@ public:
                 {
                     if (target && target->isAlive())
                     {
+                        Talk(SAY_EADRIC_HAMMER);
                         DoCast(target, SPELL_HAMMER_JUSTICE);
+                        DoScriptText(SAY_EADRIC_HAMMER_WARNING, me, target);
                         DoCast(target, SPELL_HAMMER_RIGHTEOUS);
                     }
                 }
-                uiHammerJusticeTimer = 25000;
-            } else uiHammerJusticeTimer -= uiDiff;
+                hammerJusticeTimer = 25000;
+            } else hammerJusticeTimer -= diff;
 
-            if (uiVenganceTimer <= uiDiff)
+            if (venganceTimer <= diff)
             {
                 DoCast(me, SPELL_VENGEANCE);
+                venganceTimer = 10000;
+            } else venganceTimer -= diff;
 
-                uiVenganceTimer = 10000;
-            } else uiVenganceTimer -= uiDiff;
-
-            if (uiRadianceTimer <= uiDiff)
+            if (radianceTimer <= diff)
             {
+                Talk(SAY_EADRIC_RADIANCE_WARNING);
                 DoCastAOE(SPELL_RADIANCE);
 
-                uiRadianceTimer = 16000;
-            } else uiRadianceTimer -= uiDiff;
+                radianceTimer = 16000;
+            } else radianceTimer -= diff;
 
-            DoMeleeAttackIfReady();
+            //DoMeleeAttackIfReady();
+            if (me->isAttackReady() && me->IsWithinMeleeRange(me->getVictim()))
+            {
+                me->AttackerStateUpdate(me->getVictim());
+                me->resetAttackTimer();
+
+                if (Aura* vengance = me->GetAura(SPELL_VENGANCE_AURA))
+                    if (vengance->GetDuration() < 4900)
+                        me->RemoveAurasDueToSpell(SPELL_VENGANCE_AURA);
+            }
         }
     };
 
@@ -198,6 +323,43 @@ public:
     }
 };
 
+class spell_paletress_shield : public SpellScriptLoader
+{
+    public:
+        spell_paletress_shield() : SpellScriptLoader("spell_paletress_shield") { }
+
+        class spell_paletress_shieldAuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_paletress_shieldAuraScript);
+
+            void HandleOnEffectAbsorb(AuraEffect* /*aurEff*/, DamageInfo & dmgInfo, uint32 & absorbAmount)
+            {
+                Unit* caster = GetCaster();
+                Unit* attacker = dmgInfo.GetAttacker();
+
+                if(!caster || !attacker)
+                    return;
+
+                absorbAmount = dmgInfo.GetDamage();
+                // Deal the damage and show it on caster's log
+                caster->DealDamage(attacker, (uint32)(absorbAmount*0.25f), NULL, dmgInfo.GetDamageType(), dmgInfo.GetSchoolMask());
+                caster->SendSpellNonMeleeDamageLog(attacker, GetSpellInfo()->Id, (uint32) (absorbAmount*0.25f),  dmgInfo.GetSchoolMask(), 0, 0, true, 0);
+            }
+
+            // function registering
+            void Register()
+            {
+                OnEffectAbsorb += AuraEffectAbsorbFn(spell_paletress_shieldAuraScript::HandleOnEffectAbsorb, EFFECT_0);
+            }
+        };
+
+        // function which creates AuraScript
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_paletress_shieldAuraScript();
+        }
+};
+
 class boss_paletress : public CreatureScript
 {
 public:
@@ -205,87 +367,129 @@ public:
 
     struct boss_paletressAI : public ScriptedAI
     {
-        boss_paletressAI(Creature* creature) : ScriptedAI(creature)
-        {
-            instance = creature->GetInstanceScript();
-
-            MemoryGUID = 0;
-            creature->SetReactState(REACT_PASSIVE);
-            creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-            creature->RestoreFaction();
-        }
+        boss_paletressAI(Creature* creature) : ScriptedAI(creature) {}
 
-        InstanceScript* instance;
 
-        Creature* pMemory;
-        uint64 MemoryGUID;
+        uint64 memoryGUID;
 
-        bool bHealth;
-        bool bDone;
+        bool shielded;
+        bool defeated;
 
-        uint32 uiHolyFireTimer;
-        uint32 uiHolySmiteTimer;
-        uint32 uiRenewTimer;
-        uint32 uiResetTimer;
+        uint32 holyFireTimer;
+        uint32 holySmiteTimer;
+        uint32 renewTimer;
 
         void Reset()
         {
             me->RemoveAllAuras();
+            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
 
-            uiHolyFireTimer     = urand(9000, 12000);
-            uiHolySmiteTimer    = urand(5000, 7000);
-            uiRenewTimer        = urand(2000, 5000);
+            holyFireTimer     = urand(9000, 12000);
+            holySmiteTimer    = urand(5000, 7000);
+            renewTimer        = urand(2000, 5000);
 
-            uiResetTimer        = 7000;
+            if (Creature* memory = Unit::GetCreature(*me, memoryGUID))
+                memory->DespawnOrUnsummon(1000);
 
-            bHealth = false;
-            bDone = false;
+            memoryGUID = 0;
 
-            if (Creature* pMemory = Unit::GetCreature(*me, MemoryGUID))
-                if (pMemory->isAlive())
-                    pMemory->RemoveFromWorld();
+            shielded = false;
+            defeated = false;
         }
 
-        void SetData(uint32 uiId, uint32 /*uiValue*/)
+        void SetData(uint32 id, uint32 /*value*/)
         {
-            if (uiId == 1)
+            if (id == 1)
+            {
+                if (Creature* memory = Unit::GetCreature(*me, memoryGUID))
+                    memory->DespawnOrUnsummon();
+
+                Talk(SAY_PALETRESS_MEMORY_DIES);
                 me->RemoveAura(SPELL_SHIELD);
+            }
         }
+        void EnterCombat(Unit* /*attacker*/)
+        {
+            Talk(SAY_COMMON_AGGRO);
 
-        void DamageTaken(Unit* /*done_by*/, uint32 &damage)
+            if(InstanceScript* instance = me->GetInstanceScript())
+                if(instance->GetData(BOSS_ARGENT_CHALLENGE_P) != IN_PROGRESS)
+                    instance->SetData(BOSS_ARGENT_CHALLENGE_P, IN_PROGRESS);
+        }
+
+        void JustReachedHome()
+        {
+            if(InstanceScript* instance = me->GetInstanceScript())
+                if(instance->GetData(BOSS_ARGENT_CHALLENGE_P) == IN_PROGRESS)
+                    instance->SetData(BOSS_ARGENT_CHALLENGE_P, FAIL);
+        }
+
+        void KilledUnit(Unit* /*target*/)
         {
+            Talk(SAY_COMMON_KILL);
+        }
+
+        void DamageTaken(Unit* /*attacker*/, uint32 & damage)
+        {
+            if (defeated)
+            {
+                damage = 0;
+                return;
+            }
+
+            // Prevent damage from finishing hit and mark creature as defeated
             if (damage >= me->GetHealth())
             {
                 damage = 0;
-                EnterEvadeMode();
-                me->setFaction(35);
-                bDone = true;
+                defeated = true;
+                me->SetUnitMovementFlags(MOVEMENTFLAG_WALKING);
+                me->GetMotionMaster()->MovePoint(1, me->GetHomePosition());
+                me->SetTarget(0);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                Talk(SAY_COMMON_DEATH);
+                BindPlayersToInstance(me);
+
+                if (Creature* memory = Unit::GetCreature(*me, memoryGUID))
+                    memory->DespawnOrUnsummon(1000);
+            }
+
+            if (!shielded && HealthBelowPct(25))
+            {
+                me->InterruptNonMeleeSpells(true);
+                DoCastAOE(SPELL_HOLY_NOVA, false);
+                DoCast(me, SPELL_SHIELD);
+                DoCastAOE(SPELL_SUMMON_MEMORY, false);
+                DoCastAOE(SPELL_CONFESS, false);
+                Talk(SAY_PALETRESS_SUMMON_MEMORY);
+
+                shielded = true;
             }
         }
 
-        void MovementInform(uint32 MovementType, uint32 Point)
+        void MovementInform(uint32 type, uint32 id)
         {
-            if (MovementType != POINT_MOTION_TYPE || Point != 0)
-                return;
+            if (type == POINT_MOTION_TYPE && id == 1)
+                me->DespawnOrUnsummon(0);
+        }
 
-            if (instance)
-                instance->SetData(BOSS_ARGENT_CHALLENGE_P, DONE);
+        uint32 GetData(uint32 type)
+        {
+            // Used by Announcer on periodic check of the bosses state
+            if (type == DATA_CHAMPION_DEFEATED)
+                return defeated ? 1 : 0;
 
-            me->DisappearAndDie();
+            return 0;
         }
 
-        void UpdateAI(const uint32 uiDiff)
+        void UpdateAI(const uint32 diff)
         {
-            if (bDone && uiResetTimer <= uiDiff)
-            {
-                me->GetMotionMaster()->MovePoint(0, 746.87f, 665.87f, 411.75f);
-                bDone = false;
-            } else uiResetTimer -= uiDiff;
-
             if (!UpdateVictim())
                 return;
 
-            if (uiHolyFireTimer <= uiDiff)
+            if(defeated || me->HasUnitState(UNIT_STATE_CASTING))
+                return;
+
+            if (holyFireTimer <= diff)
             {
                 if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 250, true))
                 {
@@ -293,12 +497,12 @@ public:
                         DoCast(target, SPELL_HOLY_FIRE);
                 }
                  if (me->HasAura(SPELL_SHIELD))
-                    uiHolyFireTimer = 13000;
+                    holyFireTimer = 13000;
                 else
-                    uiHolyFireTimer = urand(9000, 12000);
-            } else uiHolyFireTimer -= uiDiff;
+                    holyFireTimer = urand(9000, 12000);
+            } else holyFireTimer -= diff;
 
-            if (uiHolySmiteTimer <= uiDiff)
+            if (holySmiteTimer <= diff)
             {
                 if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 250, true))
                 {
@@ -306,41 +510,30 @@ public:
                         DoCast(target, SPELL_SMITE);
                 }
                 if (me->HasAura(SPELL_SHIELD))
-                    uiHolySmiteTimer = 9000;
+                    holySmiteTimer = 9000;
                 else
-                    uiHolySmiteTimer = urand(5000, 7000);
-            } else uiHolySmiteTimer -= uiDiff;
+                    holySmiteTimer = urand(5000, 7000);
+            } else holySmiteTimer -= diff;
 
             if (me->HasAura(SPELL_SHIELD))
             {
-                if (uiRenewTimer <= uiDiff)
+                if (renewTimer <= diff)
                 {
                     me->InterruptNonMeleeSpells(true);
-                    uint8 uiTarget = urand(0, 1);
-                    switch (uiTarget)
+                    uint8 target = urand(0, 1);
+                    switch(target)
                     {
                         case 0:
                             DoCast(me, SPELL_RENEW);
                             break;
                         case 1:
-                            if (Creature* pMemory = Unit::GetCreature(*me, MemoryGUID))
-                                if (pMemory->isAlive())
-                                    DoCast(pMemory, SPELL_RENEW);
+                            if (Creature* memory = Unit::GetCreature(*me, memoryGUID))
+                                if (memory->isAlive())
+                                    DoCast(memory, SPELL_RENEW);
                             break;
                     }
-                    uiRenewTimer = urand(15000, 17000);
-                } else uiRenewTimer -= uiDiff;
-            }
-
-            if (!bHealth && !HealthAbovePct(25))
-            {
-                me->InterruptNonMeleeSpells(true);
-                DoCastAOE(SPELL_HOLY_NOVA, false);
-                DoCast(me, SPELL_SHIELD);
-                DoCastAOE(SPELL_SUMMON_MEMORY, false);
-                DoCastAOE(SPELL_CONFESS, false);
-
-                bHealth = true;
+                    renewTimer = urand(15000, 17000);
+                } else renewTimer -= diff;
             }
 
             DoMeleeAttackIfReady();
@@ -348,7 +541,7 @@ public:
 
         void JustSummoned(Creature* summon)
         {
-            MemoryGUID = summon->GetGUID();
+            memoryGUID = summon->GetGUID();
         }
     };
 
@@ -367,47 +560,52 @@ public:
     {
         npc_memoryAI(Creature* creature) : ScriptedAI(creature) {}
 
-        uint32 uiOldWoundsTimer;
-        uint32 uiShadowPastTimer;
-        uint32 uiWakingNightmare;
+        uint32 oldWoundsTimer;
+        uint32 shadowPastTimer;
+        uint32 wakingNightmareTimer;
 
         void Reset()
         {
-            uiOldWoundsTimer = 12000;
-            uiShadowPastTimer = 5000;
-            uiWakingNightmare = 7000;
+            if (InstanceScript* instance = me->GetInstanceScript())
+                instance->SetData(DATA_MEMORY_ENTRY, me->GetEntry());
+
+            oldWoundsTimer = 12000;
+            shadowPastTimer = 5000;
+            wakingNightmareTimer = 7000;
+            DoCast(SPELL_SHADOW_FORM);
         }
 
-        void UpdateAI(const uint32 uiDiff)
+        void UpdateAI(const uint32 diff)
         {
             if (!UpdateVictim())
                 return;
 
-            if (uiOldWoundsTimer <= uiDiff)
+            if (oldWoundsTimer <= diff)
             {
-                if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0))
+                if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM))
                 {
                     if (target && target->isAlive())
                         DoCast(target, SPELL_OLD_WOUNDS);
                 }
-                uiOldWoundsTimer = 12000;
-            }else uiOldWoundsTimer -= uiDiff;
+                oldWoundsTimer = 12000;
+            }else oldWoundsTimer -= diff;
 
-            if (uiWakingNightmare <= uiDiff)
+            if (wakingNightmareTimer <= diff)
             {
+                DoScriptText(SAY_PALETRESS_NIGHTMARE_WARNING, me);
                 DoCast(me, SPELL_WAKING_NIGHTMARE);
-                uiWakingNightmare = 7000;
-            }else uiWakingNightmare -= uiDiff;
+                wakingNightmareTimer = 15000;
+            }else wakingNightmareTimer -= diff;
 
-            if (uiShadowPastTimer <= uiDiff)
+            if (shadowPastTimer <= diff)
             {
                 if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1))
                 {
                     if (target && target->isAlive())
                         DoCast(target, SPELL_SHADOWS_PAST);
                 }
-                uiShadowPastTimer = 5000;
-            }else uiShadowPastTimer -= uiDiff;
+                shadowPastTimer = 5000;
+            }else shadowPastTimer -= diff;
 
             DoMeleeAttackIfReady();
         }
@@ -427,119 +625,248 @@ public:
     }
 };
 
-class npc_argent_soldier : public CreatureScript
+class npc_argent_monk : public CreatureScript
 {
 public:
-    npc_argent_soldier() : CreatureScript("npc_argent_soldier") { }
+    npc_argent_monk() : CreatureScript("npc_argent_monk") { }
 
-    // THIS AI NEEDS MORE IMPROVEMENTS
-    struct npc_argent_soldierAI : public npc_escortAI
+    struct npc_argent_monkAI : public ScriptedAI
     {
-        npc_argent_soldierAI(Creature* creature) : npc_escortAI(creature)
+        npc_argent_monkAI(Creature* creature) : ScriptedAI(creature) {}
+
+        uint32 timerFlurryBlows;
+        uint32 timerPummel;
+        bool shieldCasted;
+        bool defeated;
+
+        void Reset()
         {
-            instance = creature->GetInstanceScript();
-            me->SetReactState(REACT_DEFENSIVE);
-            SetDespawnAtEnd(false);
-            uiWaypoint = 0;
+            timerFlurryBlows = 2000;
+            timerPummel = 1000;
+            shieldCasted = false;
+            defeated = false;
         }
 
-        InstanceScript* instance;
+        void JustReachedHome()
+        {
+            if (InstanceScript* instance = me->GetInstanceScript())
+                if (instance->GetData(MINION_ENCOUNTER) == IN_PROGRESS)
+                    instance->SetData(MINION_ENCOUNTER, FAIL);
+        }
 
-        uint8 uiWaypoint;
+        void EnterCombat(Unit* /*attacker*/)
+        {
+            if (InstanceScript* instance = me->GetInstanceScript())
+                if (instance->GetData(MINION_ENCOUNTER) != IN_PROGRESS)
+                    instance->SetData(MINION_ENCOUNTER, IN_PROGRESS);
+        }
 
-        void WaypointReached(uint32 uiPoint)
+        void DamageTaken(Unit* /*attacker*/, uint32 & damage)
         {
-            if (uiPoint == 0)
+            if (damage >= me->GetHealth() && !shieldCasted)
             {
-                switch (uiWaypoint)
-                {
-                    case 0:
-                        me->SetOrientation(5.81f);
-                        break;
-                    case 1:
-                        me->SetOrientation(4.60f);
-                        break;
-                    case 2:
-                        me->SetOrientation(2.79f);
-                        break;
-                }
-
-                me->SendMovementFlagUpdate();
+                damage = 0;
+                DoCast(me, SPELL_DIVINE_SHIELD, true);
+                DoCastVictim(SPELL_FINAL_MEDITATION);
+                shieldCasted = true;
             }
         }
 
-        void SetData(uint32 uiType, uint32 /*uiData*/)
+        void UpdateAI(const uint32 diff)
         {
-            switch (me->GetEntry())
+            if (!UpdateVictim())
+                return;
+
+            if(defeated || me->HasAura(SPELL_DIVINE_SHIELD))
+                return;
+
+            if (timerFlurryBlows <= diff)
             {
-                case NPC_ARGENT_LIGHWIELDER:
-                    switch (uiType)
-                    {
-                        case 0:
-                            AddWaypoint(0, 712.14f, 628.42f, 411.88f);
-                            break;
-                        case 1:
-                            AddWaypoint(0, 742.44f, 650.29f, 411.79f);
-                            break;
-                        case 2:
-                            AddWaypoint(0, 783.33f, 615.29f, 411.84f);
-                            break;
-                    }
-                    break;
-                case NPC_ARGENT_MONK:
-                    switch (uiType)
-                    {
-                        case 0:
-                            AddWaypoint(0, 713.12f, 632.97f, 411.90f);
-                            break;
-                        case 1:
-                            AddWaypoint(0, 746.73f, 650.24f, 411.56f);
-                            break;
-                        case 2:
-                            AddWaypoint(0, 781.32f, 610.54f, 411.82f);
-                            break;
-                    }
-                    break;
-                case NPC_PRIESTESS:
-                    switch (uiType)
-                    {
-                        case 0:
-                            AddWaypoint(0, 715.06f, 637.07f, 411.91f);
-                            break;
-                        case 1:
-                            AddWaypoint(0, 750.72f, 650.20f, 411.77f);
-                            break;
-                        case 2:
-                            AddWaypoint(0, 779.77f, 607.03f, 411.81f);
-                            break;
-                    }
-                    break;
-            }
+                DoCast(me, SPELL_FLURRY_OF_BLOWS);
+                timerFlurryBlows = urand(7000, 10000);
+            }else timerFlurryBlows -= diff;
+
+            if (timerPummel <= diff)
+            {
+                DoCastVictim(SPELL_PUMMEL);
+                timerPummel = urand(3000, 6000);
+            }else timerPummel -= diff;
 
-            Start(false, true, 0);
-            uiWaypoint = uiType;
+            DoMeleeAttackIfReady();
         }
+    };
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new npc_argent_monkAI(creature);
+    }
+};
 
-        void UpdateAI(const uint32 uiDiff)
+class npc_argent_lightwielder : public CreatureScript
+{
+public:
+    npc_argent_lightwielder() : CreatureScript("npc_argent_lightwielder") { }
+
+    struct npc_argent_lightwielderAI : public ScriptedAI
+    {
+        npc_argent_lightwielderAI(Creature* creature) : ScriptedAI(creature) {}
+
+        uint32 timerBlazingLight;
+        uint32 timerCleave;
+        uint32 timerUnbalancingStrike;
+        bool defeated;
+
+        void Reset()
         {
-            npc_escortAI::UpdateAI(uiDiff);
+            timerBlazingLight = 5000;
+            timerCleave = 2000;
+            timerUnbalancingStrike = 3000;
+            defeated = false;
+        }
 
+        void JustReachedHome()
+        {
+            if(InstanceScript* instance = me->GetInstanceScript())
+                if (instance->GetData(MINION_ENCOUNTER) == IN_PROGRESS)
+                    instance->SetData(MINION_ENCOUNTER, FAIL);
+        }
+
+        void EnterCombat(Unit* /*attacker*/)
+        {
+            if(InstanceScript* instance = me->GetInstanceScript())
+                if (instance->GetData(MINION_ENCOUNTER) != IN_PROGRESS)
+                    instance->SetData(MINION_ENCOUNTER, IN_PROGRESS);
+        }
+
+        void UpdateAI(const uint32 diff)
+        {
             if (!UpdateVictim())
                 return;
 
+            if(defeated)
+                return;
+
+            if(me->HasUnitState(UNIT_STATE_CASTING))
+                return;
+
+            if (timerBlazingLight <= diff)
+            {
+                Unit* target = DoSelectLowestHpFriendly(40);
+
+                if (!target || target->GetHealth() > me->GetHealth())
+                    target = me;
+
+                DoCast(target, SPELL_BLAZING_LIGHT);
+                timerBlazingLight = urand(8000, 10000);
+            }else timerBlazingLight -= diff;
+
+            if (timerCleave <= diff)
+            {
+                DoCastVictim(SPELL_CLEAVE);
+                timerCleave = urand(7000, 8500);
+            }else timerCleave -= diff;
+
+            if (timerUnbalancingStrike <= diff)
+            {
+                DoCastVictim(SPELL_UNBALANCING_STRIKE);
+                timerUnbalancingStrike = urand(3000, 6000);
+            }else timerUnbalancingStrike -= diff;
+
             DoMeleeAttackIfReady();
         }
+    };
 
-        void JustDied(Unit* /*killer*/)
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new npc_argent_lightwielderAI(creature);
+    }
+};
+
+class npc_argent_priest : public CreatureScript
+{
+public:
+    npc_argent_priest() : CreatureScript("npc_argent_priest") { }
+
+    struct npc_argent_priestAI : public ScriptedAI
+    {
+        npc_argent_priestAI(Creature* creature) : ScriptedAI(creature) {}
+
+        uint32 timerMindControl;
+        uint32 timerShadowWord;
+        uint32 timerFountain;
+        uint32 timerSmite;
+        bool defeated;
+
+        void Reset()
+        {
+            timerMindControl = 7000;
+            timerShadowWord = 2000;
+            timerFountain = 9000;
+            timerSmite = 1000;
+            defeated = false;
+        }
+
+        void JustReachedHome()
         {
-            if (instance)
-                instance->SetData(DATA_ARGENT_SOLDIER_DEFEATED, instance->GetData(DATA_ARGENT_SOLDIER_DEFEATED) + 1);
+            if(InstanceScript* instance = me->GetInstanceScript())
+                if (instance->GetData(MINION_ENCOUNTER) == IN_PROGRESS)
+                    instance->SetData(MINION_ENCOUNTER, FAIL);
+        }
+
+        void EnterCombat(Unit* /*attacker*/)
+        {
+            if (InstanceScript* instance = me->GetInstanceScript())
+                if (instance->GetData(MINION_ENCOUNTER) != IN_PROGRESS)
+                    instance->SetData(MINION_ENCOUNTER, IN_PROGRESS);
+        }
+
+        void UpdateAI(const uint32 diff)
+        {
+            if (!UpdateVictim())
+                return;
+
+            if (defeated)
+                return;
+
+            if (me->HasUnitState(UNIT_STATE_CASTING))
+                return;
+
+            if (timerFountain <= diff)
+            {
+                DoCast(SPELL_FOUNTAIN_OF_LIGHT);
+                timerFountain = urand(40000, 45000);
+            }else timerFountain -= diff;
+
+            if (timerMindControl <= diff)
+            {
+                if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM))
+                    DoCast(target, SPELL_MIND_CONTROL);
+                timerMindControl = urand(12000, 16000);
+                return;
+            }else timerMindControl -= diff;
+
+            if (timerShadowWord <= diff)
+            {
+                if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM))
+                    if(!target->HasAura(IsHeroic() ? SPELL_SHADOW_WORD_PAIN_H : SPELL_SHADOW_WORD_PAIN))
+                        DoCast(target, IsHeroic() ? SPELL_SHADOW_WORD_PAIN_H : SPELL_SHADOW_WORD_PAIN);
+                timerShadowWord = urand(3000, 5000);
+            }else timerShadowWord -= diff;
+
+            if (timerSmite <= diff)
+            {
+                if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM))
+                    DoCast(target, IsHeroic() ? SPELL_HOLY_SMITE_H : SPELL_HOLY_SMITE);
+                timerSmite = urand(1000, 2000);
+            } else timerSmite -= diff;
+
+            DoMeleeAttackIfReady();
         }
     };
 
     CreatureAI* GetAI(Creature* creature) const
     {
-        return new npc_argent_soldierAI(creature);
+        return new npc_argent_priestAI(creature);
     }
 };
 
@@ -547,7 +874,11 @@ void AddSC_boss_argent_challenge()
 {
     new boss_eadric();
     new spell_eadric_radiance();
+    new spell_eadric_hammer_of_righteous();
     new boss_paletress();
+    new spell_paletress_shield();
     new npc_memory();
-    new npc_argent_soldier();
+    new npc_argent_monk();
+    new npc_argent_lightwielder();
+    new npc_argent_priest();
 }
diff --git a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_black_knight.cpp b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_black_knight.cpp
index 0848d1e..e27906a 100644
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_black_knight.cpp
+++ b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_black_knight.cpp
@@ -15,14 +15,18 @@
  * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
+// Reordenada, trinity codestyle y limpieza de CRLF por Eilo
+// Waypoints mejorados y varios detalles en el movimiento
+
 /* ScriptData
 SDName: Boss Black Knight
-SD%Complete: 80%
-SDComment: missing yells. not sure about timers.
+SD%Complete: 95%
 SDCategory: Trial of the Champion
+SDComment: Editada toda la parte del vuelo del Caballero Negro para que se vea mejor
 EndScriptData */
 
 #include "ScriptPCH.h"
+#include "Vehicle.h"
 #include "ScriptedEscortAI.h"
 #include "trial_of_the_champion.h"
 
@@ -38,13 +42,15 @@ enum eSpells
     SPELL_DEATH_RESPITE_3   = 66798,
     SPELL_OBLITERATE_H      = 67883,
     SPELL_OBLITERATE        = 67725,
-    //in this phase should rise herald (the spell is missing)
+    SPELL_RAISE_ARELAS      = 67705,
+    SPELL_RAISE_JAEREN      = 67715,
 
     //phase 2 - During this phase, the Black Knight will use the same abilities as in phase 1, except for Death's Respite
     SPELL_ARMY_DEAD         = 67761,
     SPELL_DESECRATION       = 67778,
-    SPELL_DESECRATION_2     = 67778,
     SPELL_GHOUL_EXPLODE     = 67751,
+    SPELL_EXPLODE           = 67729,
+    SPELL_EXPLODE_H         = 67886,
 
     //phase 3
     SPELL_DEATH_BITE_H      = 67875,
@@ -54,10 +60,10 @@ enum eSpells
 
     SPELL_BLACK_KNIGHT_RES  = 67693,
 
+    SPELL_CLAW              = 67774,
+    SPELL_CLAW_H            = 67879,
     SPELL_LEAP              = 67749,
-    SPELL_LEAP_H            = 67880,
-
-    SPELL_KILL_CREDIT       = 68663
+    SPELL_LEAP_H            = 67880
 };
 
 enum eModels
@@ -73,6 +79,15 @@ enum ePhases
     PHASE_GHOST     = 3
 };
 
+enum Says
+{
+    SAY_AGGRO    = 1,
+    SAY_KILL     = 2,
+    SAY_SKELETON = 3,
+    SAY_GHOST    = 4,
+    SAY_DEATH    = 5,
+};
+
 class boss_black_knight : public CreatureScript
 {
 public:
@@ -80,17 +95,16 @@ public:
 
     struct boss_black_knightAI : public ScriptedAI
     {
-        boss_black_knightAI(Creature* creature) : ScriptedAI(creature)
+        boss_black_knightAI(Creature* creature) : ScriptedAI(creature), summons(creature)
         {
             instance = creature->GetInstanceScript();
         }
 
         InstanceScript* instance;
 
-        std::list<uint64> SummonList;
+        SummonList summons;
 
-        bool bEventInProgress;
-        bool bEvent;
+        bool resurrectInProgress;
         bool bSummonArmy;
         bool bDeathArmyDone;
 
@@ -109,12 +123,12 @@ public:
 
         void Reset()
         {
-            RemoveSummons();
+            summons.DespawnAll();
             me->SetDisplayId(me->GetNativeDisplayId());
-            me->ClearUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED);
+            SetEquipmentSlots(true);
+            instance->SetData(DATA_I_VE_HAD_WORSE, (uint32)true);
 
-            bEventInProgress = false;
-            bEvent = false;
+            resurrectInProgress = false;
             bSummonArmy = false;
             bDeathArmyDone = false;
 
@@ -125,50 +139,82 @@ public:
             uiDeathRespiteTimer = urand(15000, 16000);
             uiObliterateTimer = urand(17000, 19000);
             uiDesecration = urand(15000, 16000);
-            uiDeathArmyCheckTimer = 7000;
+            uiDeathArmyCheckTimer = 1000;
             uiResurrectTimer = 4000;
             uiGhoulExplodeTimer = 8000;
             uiDeathBiteTimer = urand (2000, 4000);
             uiMarkedDeathTimer = urand (5000, 7000);
         }
 
-        void RemoveSummons()
+        void EnterCombat(Unit* /*attacker*/)
         {
-            if (SummonList.empty())
-                return;
+            DoCast(instance->GetData(DATA_TEAM) == ALLIANCE ? SPELL_RAISE_ARELAS : SPELL_RAISE_JAEREN);
+            Talk(SAY_AGGRO);
+
+            if (InstanceScript* instance = me->GetInstanceScript())
+                if (instance->GetData(BOSS_BLACK_KNIGHT) != IN_PROGRESS)
+                    instance->SetData(BOSS_BLACK_KNIGHT, IN_PROGRESS);
+        }
+
+        void JustReachedHome()
+        {
+            if (InstanceScript* instance = me->GetInstanceScript())
+                if (instance->GetData(BOSS_BLACK_KNIGHT) == IN_PROGRESS)
+                    instance->SetData(BOSS_BLACK_KNIGHT, FAIL);
+        }
+
+        void KilledUnit(Unit* target)
+        {
+            if (target->GetTypeId() == TYPEID_PLAYER)
+                Talk(SAY_KILL);
+        }
 
-            for (std::list<uint64>::const_iterator itr = SummonList.begin(); itr != SummonList.end(); ++itr)
+        void JustSummoned(Creature* summon)
+        {
+            if (summon->GetEntry() == NPC_RISEN_JAEREN || summon->GetEntry() == NPC_RISEN_ARELAS || summon->GetEntry() == NPC_RISEN_CHAMPION)
             {
-                if (Creature* temp = Unit::GetCreature(*me, *itr))
-                    if (temp)
-                        temp->DisappearAndDie();
+                summons.Summon(summon);
+                summon->AI()->AttackStart(me->getVictim());
             }
-            SummonList.clear();
         }
 
-        void JustSummoned(Creature* summon)
+        void SummonedCreatureDies(Creature* summon, Unit* /*killer*/)
         {
-            SummonList.push_back(summon->GetGUID());
-            summon->AI()->AttackStart(me->getVictim());
+            summons.Despawn(summon);
+            summon->SetCorpseDelay(5*IN_MILLISECONDS);
         }
 
-        void UpdateAI(const uint32 uiDiff)
+        void UpdateAI(const uint32 diff)
         {
-            //Return since we have no target
-            if (!UpdateVictim())
+            //Return since we have no target or we are casting
+            if (!UpdateVictim() || me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
-            if (bEventInProgress)
+            if (resurrectInProgress)
             {
-                if (uiResurrectTimer <= uiDiff)
+                if (uiResurrectTimer <= diff)
                 {
                     me->SetFullHealth();
+                    switch (uiPhase)
+                    {
+                        case PHASE_UNDEAD:
+                            Talk(SAY_SKELETON);
+                            me->SetDisplayId(MODEL_SKELETON);
+                            break;
+                        case PHASE_SKELETON:
+                            Talk(SAY_GHOST);
+                            me->SetDisplayId(MODEL_GHOST);
+                            SetEquipmentSlots(false, EQUIP_UNEQUIP);
+                            me->GetMotionMaster()->MoveChase(me->getVictim());
+                            break;
+                    }
                     DoCast(me, SPELL_BLACK_KNIGHT_RES, true);
                     uiPhase++;
                     uiResurrectTimer = 4000;
-                    bEventInProgress = false;
+                    resurrectInProgress = false;
                     me->ClearUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED);
-                } else uiResurrectTimer -= uiDiff;
+                } else uiResurrectTimer -= diff;
+                return;
             }
 
             switch (uiPhase)
@@ -176,26 +222,26 @@ public:
                 case PHASE_UNDEAD:
                 case PHASE_SKELETON:
                 {
-                    if (uiIcyTouchTimer <= uiDiff)
+                    if (uiIcyTouchTimer <= diff)
                     {
                         DoCastVictim(SPELL_ICY_TOUCH);
                         uiIcyTouchTimer = urand(5000, 7000);
-                    } else uiIcyTouchTimer -= uiDiff;
-                    if (uiPlagueStrikeTimer <= uiDiff)
+                    } else uiIcyTouchTimer -= diff;
+                    if (uiPlagueStrikeTimer <= diff)
                     {
-                        DoCastVictim(SPELL_ICY_TOUCH);
+                        DoCastVictim(SPELL_PLAGUE_STRIKE);
                         uiPlagueStrikeTimer = urand(12000, 15000);
-                    } else uiPlagueStrikeTimer -= uiDiff;
-                    if (uiObliterateTimer <= uiDiff)
+                    } else uiPlagueStrikeTimer -= diff;
+                    if (uiObliterateTimer <= diff)
                     {
                         DoCastVictim(SPELL_OBLITERATE);
                         uiObliterateTimer = urand(17000, 19000);
-                    } else uiObliterateTimer -= uiDiff;
+                    } else uiObliterateTimer -= diff;
                     switch (uiPhase)
                     {
                         case PHASE_UNDEAD:
                         {
-                            if (uiDeathRespiteTimer <= uiDiff)
+                            if (uiDeathRespiteTimer <= diff)
                             {
                                 if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 100, true))
                                 {
@@ -203,7 +249,7 @@ public:
                                         DoCast(target, SPELL_DEATH_RESPITE);
                                 }
                                 uiDeathRespiteTimer = urand(15000, 16000);
-                            } else uiDeathRespiteTimer -= uiDiff;
+                            } else uiDeathRespiteTimer -= diff;
                             break;
                         }
                         case PHASE_SKELETON:
@@ -216,14 +262,14 @@ public:
                             }
                             if (!bDeathArmyDone)
                             {
-                                if (uiDeathArmyCheckTimer <= uiDiff)
+                                if (uiDeathArmyCheckTimer <= diff)
                                 {
-                                    me->ClearUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED);
+                                    me->GetMotionMaster()->MoveChase(me->getVictim());
                                     uiDeathArmyCheckTimer = 0;
                                     bDeathArmyDone = true;
-                                } else uiDeathArmyCheckTimer -= uiDiff;
+                                } else uiDeathArmyCheckTimer -= diff;
                             }
-                            if (uiDesecration <= uiDiff)
+                            if (uiDesecration <= diff)
                             {
                                 if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 100, true))
                                 {
@@ -231,12 +277,12 @@ public:
                                         DoCast(target, SPELL_DESECRATION);
                                 }
                                 uiDesecration = urand(15000, 16000);
-                            } else uiDesecration -= uiDiff;
-                            if (uiGhoulExplodeTimer <= uiDiff)
+                            } else uiDesecration -= diff;
+                            if (!summons.empty() && uiGhoulExplodeTimer <= diff)
                             {
                                 DoCast(me, SPELL_GHOUL_EXPLODE);
                                 uiGhoulExplodeTimer = 8000;
-                            } else uiGhoulExplodeTimer -= uiDiff;
+                            } else uiGhoulExplodeTimer -= diff;
                             break;
                         }
                         break;
@@ -245,12 +291,12 @@ public:
                 }
                 case PHASE_GHOST:
                 {
-                    if (uiDeathBiteTimer <= uiDiff)
+                    if (uiDeathBiteTimer <= diff)
                     {
                         DoCastAOE(SPELL_DEATH_BITE);
-                        uiDeathBiteTimer = urand (2000, 4000);
-                    } else uiDeathBiteTimer -= uiDiff;
-                    if (uiMarkedDeathTimer <= uiDiff)
+                        uiDeathBiteTimer = urand (8000, 12000);
+                    } else uiDeathBiteTimer -= diff;
+                    if (uiMarkedDeathTimer <= diff)
                     {
                         if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 100, true))
                         {
@@ -258,7 +304,7 @@ public:
                                 DoCast(target, SPELL_MARKED_DEATH);
                         }
                         uiMarkedDeathTimer = urand (5000, 7000);
-                    } else uiMarkedDeathTimer -= uiDiff;
+                    } else uiMarkedDeathTimer -= diff;
                     break;
                 }
             }
@@ -267,31 +313,32 @@ public:
                 DoMeleeAttackIfReady();
         }
 
-        void DamageTaken(Unit* /*pDoneBy*/, uint32& uiDamage)
+        void DamageTaken(Unit* /*pDoneBy*/, uint32& damage)
         {
-            if (uiDamage > me->GetHealth() && uiPhase <= PHASE_SKELETON)
+            if (damage > me->GetHealth() && uiPhase <= PHASE_SKELETON)
             {
-                uiDamage = 0;
+                damage = 0;
                 me->SetHealth(0);
                 me->AddUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED);
-                RemoveSummons();
-                switch (uiPhase)
-                {
-                    case PHASE_UNDEAD:
-                        me->SetDisplayId(MODEL_SKELETON);
-                        break;
-                    case PHASE_SKELETON:
-                        me->SetDisplayId(MODEL_GHOST);
-                        break;
-                }
-                bEventInProgress = true;
+                me->GetMotionMaster()->MoveIdle();
+                resurrectInProgress = true;
+                ExplodeAliveGhouls();
             }
         }
 
-        void JustDied(Unit* /*killer*/)
+        void ExplodeAliveGhouls()
         {
-            DoCast(me, SPELL_KILL_CREDIT);
+            if (summons.empty())
+                return;
+
+            for (SummonList::iterator itr = summons.begin(); itr != summons.end(); ++itr)
+                if (Creature* ghoul = me->GetCreature(*me, *itr))
+                    ghoul->CastSpell(ghoul, SPELL_EXPLODE);
+        }
 
+        void JustDied(Unit* /*killer*/)
+        {
+            Talk(SAY_DEATH);
             if (instance)
                 instance->SetData(BOSS_BLACK_KNIGHT, DONE);
         }
@@ -312,27 +359,47 @@ public:
     {
         npc_risen_ghoulAI(Creature* creature) : ScriptedAI(creature) {}
 
+        InstanceScript* instance;
         uint32 uiAttackTimer;
+        uint32 uiLeapTimer;
 
         void Reset()
         {
+            instance = me->GetInstanceScript();
             uiAttackTimer = 3500;
+            uiLeapTimer = 1000;
+
+            if (Creature* knight = me->GetCreature(*me, instance->GetData64(DATA_BLACK_KNIGHT)))
+                knight->AI()->JustSummoned(me);
         }
 
-        void UpdateAI(const uint32 uiDiff)
+        void SpellHitTarget(Unit* /*victim*/, const SpellInfo* spell)
         {
-            if (!UpdateVictim())
+            if (spell->Id == SPELL_EXPLODE_H)
+                instance->SetData(DATA_I_VE_HAD_WORSE, (uint32)false);
+        }
+
+        void UpdateAI(const uint32 diff)
+        {
+            if (!UpdateVictim() || me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
-            if (uiAttackTimer <= uiDiff)
+            if (uiLeapTimer <= diff)
             {
-                if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100, true))
+                if (Unit* target = SelectTarget(SELECT_TARGET_FARTHEST, 0, 30, true))
                 {
-                    if (target && target->isAlive())
-                        DoCast(target, (SPELL_LEAP));
+                    DoResetThreat();
+                    me->AddThreat(target, 5.0f);
+                    DoCast(target, SPELL_LEAP);
                 }
-                uiAttackTimer = 3500;
-            } else uiAttackTimer -= uiDiff;
+                uiLeapTimer = urand(7000, 10000);
+            } else uiLeapTimer -= diff;
+
+            if (uiAttackTimer <= diff)
+            {
+                DoCastVictim(SPELL_CLAW);
+                uiAttackTimer = urand(1000, 3500);
+            } else uiAttackTimer -= diff;
 
             DoMeleeAttackIfReady();
         }
@@ -351,19 +418,90 @@ public:
 
     struct npc_black_knight_skeletal_gryphonAI : public npc_escortAI
     {
-        npc_black_knight_skeletal_gryphonAI(Creature* creature) : npc_escortAI(creature)
+        npc_black_knight_skeletal_gryphonAI(Creature* creature) : npc_escortAI(creature), _vehicleKit(creature->GetVehicleKit())
         {
-            Start(false, true, 0, NULL);
+            instance = creature->GetInstanceScript();
+            me->SetSpeed(MOVE_FLIGHT, 2.8f);
         }
 
-        void WaypointReached(uint32 /*i*/)
+        Vehicle* _vehicleKit;
+        InstanceScript* instance;
+
+        void SetData(uint32 type, uint32 data)
         {
+            if (type == 1)
+                Start(false, true, 0, NULL);
+        }
 
+        void WaypointReached(uint32 id)
+        {
+            switch (id)
+            {
+                case 1:
+                me->SetUnitMovementFlags(MOVEMENTFLAG_FLYING);
+                me->SetSpeed(MOVE_FLIGHT , 2.0f);
+                break;
+                case 2:
+                me->SetUnitMovementFlags(MOVEMENTFLAG_FLYING);
+                me->SetSpeed(MOVE_FLIGHT , 2.0f);
+                break;
+                case 3:
+                me->SetUnitMovementFlags(MOVEMENTFLAG_FLYING);
+                me->SetSpeed(MOVE_FLIGHT , 2.0f);
+                break;
+                case 4:
+                me->SetUnitMovementFlags(MOVEMENTFLAG_FLYING);
+                me->SetSpeed(MOVE_FLIGHT , 2.0f);
+                break;
+                case 5:
+                me->SetUnitMovementFlags(MOVEMENTFLAG_FLYING);
+                me->SetSpeed(MOVE_FLIGHT , 2.0f);
+                break;
+                case 6:
+                me->SetUnitMovementFlags(MOVEMENTFLAG_FLYING);
+                me->SetSpeed(MOVE_FLIGHT , 2.0f);
+                break;
+                case 7:
+                me->SetUnitMovementFlags(MOVEMENTFLAG_FLYING);
+                me->SetSpeed(MOVE_FLIGHT , 2.0f);
+                break;
+                case 8:
+                me->SetUnitMovementFlags(MOVEMENTFLAG_FLYING);
+                me->SetSpeed(MOVE_FLIGHT , 2.0f);
+                break;
+                case 9:
+                me->SetUnitMovementFlags(MOVEMENTFLAG_FLYING);
+                me->SetSpeed(MOVE_FLIGHT , 2.0f);
+                break;
+                case 10:
+                me->SetUnitMovementFlags(MOVEMENTFLAG_FLYING);
+                me->SetSpeed(MOVE_FLIGHT , 2.0f);
+                break;
+                case 11:
+                me->SetUnitMovementFlags(MOVEMENTFLAG_FLYING);
+                me->SetSpeed(MOVE_FLIGHT , 2.0f);
+                break;
+                case 12:
+                me->SetUnitMovementFlags(MOVEMENTFLAG_WALKING);
+                me->SetSpeed(MOVE_RUN, 2.0f);
+                break;
+                case 13:
+                me->SetUnitMovementFlags(MOVEMENTFLAG_FLYING);
+                if (Unit* blackKnight = _vehicleKit->GetPassenger(0))
+                    blackKnight->ExitVehicle();
+                break;
+            }
+        }
+
+        void PassengerBoarded(Unit* who, int8 /*seatId*/, bool /*apply*/)
+        {
+            if (who->GetTypeId() == TYPEID_PLAYER)
+                who->ExitVehicle();
         }
 
-        void UpdateAI(const uint32 uiDiff)
+        void UpdateAI(const uint32 diff)
         {
-            npc_escortAI::UpdateAI(uiDiff);
+            npc_escortAI::UpdateAI(diff);
 
             if (!UpdateVictim())
                 return;
diff --git a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_grand_champions.cpp b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_grand_champions.cpp
index 9fcfcfa..aa0cde1 100644
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_grand_champions.cpp
+++ b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/boss_grand_champions.cpp
@@ -18,22 +18,25 @@
 
 /* ScriptData
 SDName: boss_grand_champions
-SD%Complete: 50 %
+SD%Complete: 80 %
 SDComment: Is missing the ai to make the npcs look for a new mount and use it.
 SDCategory: Trial Of the Champion
 EndScriptData */
 
 #include "ScriptPCH.h"
-#include "ScriptedEscortAI.h"
 #include "Vehicle.h"
 #include "trial_of_the_champion.h"
 
 enum eSpells
 {
     //Vehicle
-    SPELL_CHARGE                    = 63010,
-    SPELL_SHIELD_BREAKER            = 68504,
+    SPELL_CHARGE                    = 68282,
+    SPELL_SHIELD_BREAKER            = 62575,
+    SPELL_SHIELD_BREAKER_VISUAL     = 45815,
     SPELL_SHIELD                    = 66482,
+    SPELL_THRUST                    = 62544,
+    SPELL_KNEE                      = 68442,
+    // 67870
 
     // Marshal Jacob Alerius && Mokra the Skullcrusher || Warrior
     SPELL_MORTAL_STRIKE             = 68783,
@@ -58,240 +61,212 @@ enum eSpells
     SPELL_HEALING_WAVE              = 67528,
     SPELL_HEALING_WAVE_H            = 68318,
     SPELL_HEX_OF_MENDING            = 67534,
+    SPELL_HEX_OF_MENDING_HEAL       = 67535,
 
     // Jaelyne Evensong && Zul'tore || Hunter
-    SPELL_DISENGAGE                 = 68340, //not implemented in the AI yet...
-    SPELL_LIGHTNING_ARROWS          = 66083,
+    SPELL_DISENGAGE                 = 68339,
+    SPELL_LIGHTNING_ARROWS          = 66085,
+    SPELL_LIGHTNING_ARROWS_DAMAGE   = 66095,
+    SPELL_LIGHTNING_ARROWS_VISUAL   = 66083,
     SPELL_MULTI_SHOT                = 66081,
     SPELL_SHOOT                     = 65868,
     SPELL_SHOOT_H                   = 67988,
 
     // Lana Stouthammer Evensong && Deathstalker Visceri || Rouge
+    SPELL_DEADLY_POISON             = 67711,
     SPELL_EVISCERATE                = 67709,
     SPELL_EVISCERATE_H              = 68317,
     SPELL_FAN_OF_KNIVES             = 67706,
-    SPELL_POISON_BOTTLE             = 67701
-};
-
-enum eSeat
-{
-    SEAT_ID_0                       = 0
+    SPELL_POISON_BOTTLE             = 67701,
+    SPELL_DUAL_WIELD                = 42459,
 };
 
 /*
-struct Point
-{
-    float x, y, z;
-};
-
-const Point MovementPoint[] =
-{
-  {746.84f, 623.15f, 411.41f},
-  {747.96f, 620.29f, 411.09f},
-  {750.23f, 618.35f, 411.09f}
-};
+* Generic AI for vehicles used by npcs in ToC, it needs more improvements.  *
+* Script Complete: 25%.                                                     *
 */
-void AggroAllPlayers(Creature* temp)
+
+struct npc_mounted_championAI : ScriptedAI
 {
-    Map::PlayerList const &PlList = temp->GetMap()->GetPlayers();
+    npc_mounted_championAI(Creature* creature) : ScriptedAI(creature)
+    {
+        instance = me->GetInstanceScript();
+    }
 
-    if (PlList.isEmpty())
-            return;
+    InstanceScript* instance;
+
+    uint32 chargeTimer;
+    uint32 shieldBreakerTimer;
+    uint32 buffTimer;
+    bool _defeated;
 
-    for (Map::PlayerList::const_iterator i = PlList.begin(); i != PlList.end(); ++i)
+    void Reset()
     {
-        if (Player* player = i->getSource())
-        {
-            if (player->isGameMaster())
-                continue;
+        if(_defeated)
+            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+
+        me->Mount(GetMountId());
+        chargeTimer = urand(1000, 5000);
+        shieldBreakerTimer = 8000;
+        buffTimer = urand(4000, 5000);
+        _defeated = false;
+        if (instance)
+            SetEquipmentSlots(false, instance->GetData(DATA_TEAM) == ALLIANCE ? 46070 : 46069);
+    }
 
-            if (player->isAlive())
-            {
-                temp->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
-                temp->SetReactState(REACT_AGGRESSIVE);
-                temp->SetInCombatWith(player);
-                player->SetInCombatWith(temp);
-                temp->AddThreat(player, 0.0f);
-            }
+    uint32 GetMountId()
+    {
+        switch(me->GetEntry())
+        {
+            // Alliance
+            case NPC_STORMWIND_CHAMPION:  return 28912;
+            case NPC_IRONFORGE_CHAMPION:  return 29258;
+            case NPC_GNOMEREGAN_CHAMPION: return 28571;
+            case NPC_DARNASSUS_CHAMPION:  return 29256;
+            case NPC_EXODAR_CHAMPION:     return 29255;
+            case NPC_JACOB:               return 29284;
+            case NPC_AMBROSE:             return 28571;
+            case NPC_COLOSOS:             return 29255;
+            case NPC_JAELYNE:             return 9991;
+            case NPC_LANA:                return 2787;
+            // Horde
+            case NPC_ORGRIMMAR_CHAMPION:     return 29260;
+            case NPC_THUNDER_BLUFF_CHAMPION: return 29259;
+            case NPC_UNDERCITY_CHAMPION:     return 29257;
+            case NPC_SENJIN_CHAMPION:        return 29261;
+            case NPC_SILVERMOON_CHAMPION:    return 29262;
+            case NPC_MOKRA:                  return 29879;
+            case NPC_ERESSEA:                return 28607;
+            case NPC_RUNOK:                  return 29880;
+            case NPC_ZULTORE:                return 29261;
+            case NPC_VISCERI:                return 10718;
         }
+        return 0;
     }
-}
 
-bool GrandChampionsOutVehicle(Creature* me)
-{
-    InstanceScript* instance = me->GetInstanceScript();
+    void DamageTaken(Unit* /*attacker*/, uint32 & damage)
+    {
+        if (!isGrandChampion())
+            return;
 
-    if (!instance)
-        return false;
+        if(_defeated)
+        {
+            damage = 0;
+            return;
+        }
 
-    Creature* pGrandChampion1 = Unit::GetCreature(*me, instance->GetData64(DATA_GRAND_CHAMPION_1));
-    Creature* pGrandChampion2 = Unit::GetCreature(*me, instance->GetData64(DATA_GRAND_CHAMPION_2));
-    Creature* pGrandChampion3 = Unit::GetCreature(*me, instance->GetData64(DATA_GRAND_CHAMPION_3));
+        if(damage >= me->GetHealth())
+        {
+            damage = 0;
+            _defeated = true;
+            me->GetMotionMaster()->MoveIdle();
+            me->Dismount();
+            me->RemoveAurasDueToSpell(SPELL_SHIELD);
+            me->CastSpell(me, SPELL_KNEE, true);
+            me->SetTarget(0);
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        }
+    }
 
-    if (pGrandChampion1 && pGrandChampion2 && pGrandChampion3)
+    uint32 GetData(uint32 type)
     {
-        if (!pGrandChampion1->HasUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT) &&
-            !pGrandChampion2->HasUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT) &&
-            !pGrandChampion3->HasUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT))
-            return true;
+        if(type == DATA_CHAMPION_DEFEATED)
+            return _defeated ? 1 : 0;
+
+        return 0;
     }
 
-    return false;
-}
+    void EnterCombat(Unit* /*who*/)
+    {
+        // Set Defend to 3 charges at start
+        for (uint8 i = 0; i < 3; ++i)
+            DoCast(me, SPELL_SHIELD, true);
 
-/*
-* Generic AI for vehicles used by npcs in ToC, it needs more improvements.  *
-* Script Complete: 25%.                                                     *
-*/
+        if (instance->GetData(MINION_ENCOUNTER) != IN_PROGRESS)
+            instance->SetData(MINION_ENCOUNTER, IN_PROGRESS);
+    }
 
-class generic_vehicleAI_toc5 : public CreatureScript
-{
-public:
-    generic_vehicleAI_toc5() : CreatureScript("generic_vehicleAI_toc5") { }
+    void JustReachedHome()
+    {
+        if (instance->GetData(MINION_ENCOUNTER) == IN_PROGRESS)
+            instance->SetData(MINION_ENCOUNTER, FAIL);
+    }
 
-    struct generic_vehicleAI_toc5AI : public npc_escortAI
+    bool isGrandChampion()
     {
-        generic_vehicleAI_toc5AI(Creature* creature) : npc_escortAI(creature)
-        {
-            SetDespawnAtEnd(false);
-            uiWaypointPath = 0;
+        return (me->GetEntry() == NPC_MOKRA   || me->GetEntry() == NPC_JACOB   ||
+                me->GetEntry() == NPC_ERESSEA || me->GetEntry() == NPC_AMBROSE ||
+                me->GetEntry() == NPC_RUNOK   || me->GetEntry() == NPC_COLOSOS ||
+                me->GetEntry() == NPC_ZULTORE || me->GetEntry() == NPC_JAELYNE ||
+                me->GetEntry() == NPC_VISCERI || me->GetEntry() == NPC_LANA);
+    }
 
-            instance = creature->GetInstanceScript();
+    bool isInMountedGauntlet()
+    {
+        if(Creature* announcer = me->GetCreature(*me, instance->GetData64(DATA_ANNOUNCER)))
+        {
+            if (announcer->AI()->GetData(EVENT_INTRO) == IN_PROGRESS || announcer->AI()->GetData(EVENT_WAVES) == IN_PROGRESS)
+                return true;
         }
+        return false;
+    }
 
-        InstanceScript* instance;
-
-        uint32 uiChargeTimer;
-        uint32 uiShieldBreakerTimer;
-        uint32 uiBuffTimer;
-
-        uint32 uiWaypointPath;
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!UpdateVictim())
+            return;
 
-        void Reset()
-        {
-            uiChargeTimer = 5000;
-            uiShieldBreakerTimer = 8000;
-            uiBuffTimer = urand(30000, 60000);
-        }
+        if(_defeated)
+            return;
 
-        void SetData(uint32 uiType, uint32 /*uiData*/)
+        if (buffTimer <= uiDiff)
         {
-            switch (uiType)
+            Aura* defend = me->GetAura(SPELL_SHIELD);
+            if (!defend || defend->GetStackAmount() < 3)
             {
-                case 1:
-                    AddWaypoint(0, 747.36f, 634.07f, 411.572f);
-                    AddWaypoint(1, 780.43f, 607.15f, 411.82f);
-                    AddWaypoint(2, 785.99f, 599.41f, 411.92f);
-                    AddWaypoint(3, 778.44f, 601.64f, 411.79f);
-                    uiWaypointPath = 1;
-                    break;
-                case 2:
-                    AddWaypoint(0, 747.35f, 634.07f, 411.57f);
-                    AddWaypoint(1, 768.72f, 581.01f, 411.92f);
-                    AddWaypoint(2, 763.55f, 590.52f, 411.71f);
-                    uiWaypointPath = 2;
-                    break;
-                case 3:
-                    AddWaypoint(0, 747.35f, 634.07f, 411.57f);
-                    AddWaypoint(1, 784.02f, 645.33f, 412.39f);
-                    AddWaypoint(2, 775.67f, 641.91f, 411.91f);
-                    uiWaypointPath = 3;
-                    break;
-            }
+                DoCast(SPELL_SHIELD);
+                buffTimer = urand(4000, 5000);
+            } else buffTimer = urand(1000, 2000);
+        }else buffTimer -= uiDiff;
 
-            if (uiType <= 3)
-                Start(false, true, 0, NULL);
-        }
-
-        void WaypointReached(uint32 i)
+        if (chargeTimer <= uiDiff)
         {
-            switch (i)
+            if(Unit* target = SelectTarget(SELECT_TARGET_FARTHEST))
             {
-                case 2:
-                    if ((instance && uiWaypointPath == 3) || uiWaypointPath == 2)
-                        instance->SetData(DATA_MOVEMENT_DONE, instance->GetData(DATA_MOVEMENT_DONE)+1);
-                    break;
-                case 3:
-                    if (instance)
-                        instance->SetData(DATA_MOVEMENT_DONE, instance->GetData(DATA_MOVEMENT_DONE)+1);
-                    break;
+                DoResetThreat();
+                me->AddThreat(target, 5.0f);
+                DoCast(target, SPELL_CHARGE, true);
             }
-        }
+            chargeTimer = 5000;
+        }else chargeTimer -= uiDiff;
 
-        void EnterCombat(Unit* /*who*/)
+        if (shieldBreakerTimer <= uiDiff)
         {
-            DoCastSpellShield();
-        }
+            if(Unit* target = SelectTarget(SELECT_TARGET_FARTHEST))
+                DoCast(target, SPELL_SHIELD_BREAKER, true);
 
-        void DoCastSpellShield()
-        {
-            for (uint8 i = 0; i < 3; ++i)
-                DoCast(me, SPELL_SHIELD, true);
-        }
+            shieldBreakerTimer = 7000;
+        }else shieldBreakerTimer -= uiDiff;
 
-        void UpdateAI(const uint32 uiDiff)
+        // Use Thrust instead of melee attack
+        if (me->isAttackReady() && me->IsWithinMeleeRange(me->getVictim()))
         {
-            npc_escortAI::UpdateAI(uiDiff);
-
-            if (!UpdateVictim())
-                return;
-
-            if (uiBuffTimer <= uiDiff)
-            {
-                if (!me->HasAura(SPELL_SHIELD))
-                    DoCastSpellShield();
-
-                uiBuffTimer = urand(30000, 45000);
-            }else uiBuffTimer -= uiDiff;
-
-            if (uiChargeTimer <= uiDiff)
-            {
-                Map::PlayerList const& players = me->GetMap()->GetPlayers();
-                if (me->GetMap()->IsDungeon() && !players.isEmpty())
-                {
-                    for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
-                    {
-                        Player* player = itr->getSource();
-                        if (player && !player->isGameMaster() && me->IsInRange(player, 8.0f, 25.0f, false))
-                        {
-                            DoResetThreat();
-                            me->AddThreat(player, 1.0f);
-                            DoCast(player, SPELL_CHARGE);
-                            break;
-                        }
-                    }
-                }
-                uiChargeTimer = 5000;
-            }else uiChargeTimer -= uiDiff;
-
-            //dosen't work at all
-            if (uiShieldBreakerTimer <= uiDiff)
-            {
-                Vehicle* pVehicle = me->GetVehicleKit();
-                if (!pVehicle)
-                    return;
+            me->AddUnitState(UNIT_STATE_ONVEHICLE);
+            DoCast(me->getVictim(), SPELL_THRUST);
+            me->resetAttackTimer();
+            me->ClearUnitState(UNIT_STATE_ONVEHICLE);
+        }
+    }
+};
 
-                if (Unit* pPassenger = pVehicle->GetPassenger(SEAT_ID_0))
-                {
-                    Map::PlayerList const& players = me->GetMap()->GetPlayers();
-                    if (me->GetMap()->IsDungeon() && !players.isEmpty())
-                    {
-                        for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
-                        {
-                            Player* player = itr->getSource();
-                            if (player && !player->isGameMaster() && me->IsInRange(player, 10.0f, 30.0f, false))
-                            {
-                                pPassenger->CastSpell(player, SPELL_SHIELD_BREAKER, true);
-                                break;
-                            }
-                        }
-                    }
-                }
-                uiShieldBreakerTimer = 7000;
-            }else uiShieldBreakerTimer -= uiDiff;
+class generic_vehicleAI_toc5 : public CreatureScript
+{
+public:
+    generic_vehicleAI_toc5() : CreatureScript("generic_vehicleAI_toc5") { }
 
-            DoMeleeAttackIfReady();
-        }
+    struct generic_vehicleAI_toc5AI : public npc_mounted_championAI
+    {
+        generic_vehicleAI_toc5AI(Creature* creature) : npc_mounted_championAI(creature) {}
     };
 
     CreatureAI* GetAI(Creature* creature) const
@@ -306,86 +281,118 @@ public:
     boss_warrior_toc5() : CreatureScript("boss_warrior_toc5") { }
 
     // Marshal Jacob Alerius && Mokra the Skullcrusher || Warrior
-    struct boss_warrior_toc5AI : public ScriptedAI
+    struct boss_warrior_toc5AI : public npc_mounted_championAI
     {
-        boss_warrior_toc5AI(Creature* creature) : ScriptedAI(creature)
-        {
-            instance = creature->GetInstanceScript();
+        boss_warrior_toc5AI(Creature* creature) : npc_mounted_championAI(creature) {}
 
-            bDone = false;
-            bHome = false;
+        uint32 bladeStormTimer;
+        uint32 interceptTimer;
+        uint32 mortalStrikeTimer;
+        bool defeated;
 
-            uiPhase = 0;
-            uiPhaseTimer = 0;
+        void Reset()
+        {
+            if (isInMountedGauntlet())
+            {
+                npc_mounted_championAI::Reset();
+                return;
+            }
 
-            me->SetReactState(REACT_PASSIVE);
-            // THIS IS A HACK, SHOULD BE REMOVED WHEN THE EVENT IS FULL SCRIPTED
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
+            defeated = false;
+            bladeStormTimer = urand(15000, 20000);
+            interceptTimer  = 7000;
+            mortalStrikeTimer = urand(8000, 12000);
+            me->RemoveUnitMovementFlag(MOVEMENTFLAG_WALKING);
+            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
         }
 
-        InstanceScript* instance;
-
-        uint8 uiPhase;
-        uint32 uiPhaseTimer;
+        void DamageTaken(Unit* /*attacker*/, uint32 & damage)
+        {
+            if (isInMountedGauntlet())
+            {
+                npc_mounted_championAI::DamageTaken(NULL, damage);
+                return;
+            }
 
-        uint32 uiBladeStormTimer;
-        uint32 uiInterceptTimer;
-        uint32 uiMortalStrikeTimer;
-        uint32 uiAttackTimer;
+            if(defeated)
+            {
+                damage = 0;
+                return;
+            }
 
-        bool bDone;
-        bool bHome;
+            // Prevent damage from finishing hit and mark creature as defeated
+            if(damage >= me->GetHealth())
+            {
+                damage = 0;
+                defeated = true;
+                me->SetUnitMovementFlags(MOVEMENTFLAG_WALKING);
+                me->GetMotionMaster()->MovePoint(1, me->GetHomePosition());
+                me->SetTarget(0);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                BindPlayersToInstance(me);
+            }
+        }
 
-        void Reset()
+        void MovementInform(uint32 type, uint32 id)
         {
-            uiBladeStormTimer = urand(15000, 20000);
-            uiInterceptTimer  = 7000;
-            uiMortalStrikeTimer = urand(8000, 12000);
+            // Knee at home position after being defeated
+            if(type == POINT_MOTION_TYPE && id == 1)
+                me->CastSpell(me, SPELL_KNEE, true);
         }
 
-        void JustReachedHome()
+        uint32 GetData(uint32 type)
         {
-            ScriptedAI::JustReachedHome();
+            if (isInMountedGauntlet())
+                return npc_mounted_championAI::GetData(type);
 
-            if (!bHome)
-                return;
-
-            uiPhaseTimer = 15000;
-            uiPhase = 1;
+            // Used by Announcer on periodic check of the bosses state
+            if(type == DATA_CHAMPION_DEFEATED)
+                return defeated ? 1 : 0;
 
-            bHome = false;
+            return 0;
         }
 
-        void UpdateAI(const uint32 uiDiff)
+        void EnterCombat(Unit* who)
         {
-            if (!bDone && GrandChampionsOutVehicle(me))
+            if (isInMountedGauntlet())
             {
-                bDone = true;
+                npc_mounted_championAI::EnterCombat(who);
+                return;
+            }
 
-                if (instance && me->GetGUID() == instance->GetData64(DATA_GRAND_CHAMPION_1))
-                    me->SetHomePosition(739.678f, 662.541f, 412.393f, 4.49f);
-                else if (instance && me->GetGUID() == instance->GetData64(DATA_GRAND_CHAMPION_2))
-                    me->SetHomePosition(746.71f, 661.02f, 411.69f, 4.6f);
-                else if (instance && me->GetGUID() == instance->GetData64(DATA_GRAND_CHAMPION_3))
-                    me->SetHomePosition(754.34f, 660.70f, 412.39f, 4.79f);
+            if(InstanceScript* instance = me->GetInstanceScript())
+                if(instance->GetData(BOSS_GRAND_CHAMPIONS) != IN_PROGRESS)
+                    instance->SetData(BOSS_GRAND_CHAMPIONS, IN_PROGRESS);
+        };
 
-                EnterEvadeMode();
-                bHome = true;
+        void JustReachedHome()
+        {
+            if (isInMountedGauntlet())
+            {
+                npc_mounted_championAI::JustReachedHome();
+                return;
             }
 
-            if (uiPhaseTimer <= uiDiff)
+            if(InstanceScript* instance = me->GetInstanceScript())
+                if(instance->GetData(BOSS_GRAND_CHAMPIONS) == IN_PROGRESS)
+                    instance->SetData(BOSS_GRAND_CHAMPIONS, FAIL);
+        }
+
+        void UpdateAI(const uint32 diff)
+        {
+            if (isInMountedGauntlet())
             {
-                if (uiPhase == 1)
-                {
-                    AggroAllPlayers(me);
-                    uiPhase = 0;
-                }
-            }else uiPhaseTimer -= uiDiff;
+                npc_mounted_championAI::UpdateAI(diff);
+                return;
+            }
+
+            if (!UpdateVictim())
+                return;
 
-            if (!UpdateVictim() || me->HasUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT))
+            if(defeated)
                 return;
 
-            if (uiInterceptTimer <= uiDiff)
+            if (interceptTimer <= diff)
             {
                 Map::PlayerList const& players = me->GetMap()->GetPlayers();
                 if (me->GetMap()->IsDungeon() && !players.isEmpty())
@@ -401,30 +408,24 @@ public:
                             break;
                         }
                     }
-                }
-                uiInterceptTimer = 7000;
-            } else uiInterceptTimer -= uiDiff;
+                   }
+                interceptTimer = 7000;
+            } else interceptTimer -= diff;
 
-            if (uiBladeStormTimer <= uiDiff)
+            if (bladeStormTimer <= diff)
             {
                 DoCastVictim(SPELL_BLADESTORM);
-                uiBladeStormTimer = urand(15000, 20000);
-            } else uiBladeStormTimer -= uiDiff;
+                bladeStormTimer = urand(15000, 20000);
+            } else bladeStormTimer -= diff;
 
-            if (uiMortalStrikeTimer <= uiDiff)
+            if (mortalStrikeTimer <= diff)
             {
                 DoCastVictim(SPELL_MORTAL_STRIKE);
-                uiMortalStrikeTimer = urand(8000, 12000);
-            } else uiMortalStrikeTimer -= uiDiff;
+                mortalStrikeTimer = urand(8000, 12000);
+            } else mortalStrikeTimer -= diff;
 
             DoMeleeAttackIfReady();
         }
-
-        void JustDied(Unit* /*killer*/)
-        {
-            if (instance)
-                instance->SetData(BOSS_GRAND_CHAMPIONS, DONE);
-        }
     };
 
     CreatureAI* GetAI(Creature* creature) const
@@ -439,130 +440,150 @@ public:
     boss_mage_toc5() : CreatureScript("boss_mage_toc5") { }
 
     // Ambrose Boltspark && Eressea Dawnsinger || Mage
-    struct boss_mage_toc5AI : public ScriptedAI
+    struct boss_mage_toc5AI : public npc_mounted_championAI
     {
-        boss_mage_toc5AI(Creature* creature) : ScriptedAI(creature)
-        {
-            instance = creature->GetInstanceScript();
+        boss_mage_toc5AI(Creature* creature) : npc_mounted_championAI(creature) {}
 
-            bDone = false;
-            bHome = false;
+        uint32 fireBallTimer;
+        uint32 blastWaveTimer;
+        uint32 hasteTimer;
+        uint32 polymorphTimer;
+        bool defeated;
 
-            uiPhase = 0;
-            uiPhaseTimer = 0;
+        void Reset()
+        {
+            if (isInMountedGauntlet())
+            {
+                npc_mounted_championAI::Reset();
+                return;
+            }
 
-            me->SetReactState(REACT_PASSIVE);
-            // THIS IS A HACK, SHOULD BE REMOVED WHEN THE EVENT IS FULL SCRIPTED
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
+            defeated = false;
+            fireBallTimer = 2000;
+            polymorphTimer  = 8000;
+            blastWaveTimer = 12000;
+            hasteTimer = 22000;
+            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            me->RemoveUnitMovementFlag(MOVEMENTFLAG_WALKING);
         }
 
-        InstanceScript* instance;
-
-        uint8 uiPhase;
-        uint32 uiPhaseTimer;
+        void DamageTaken(Unit* /*attacker*/, uint32 & damage)
+        {
+            if (isInMountedGauntlet())
+            {
+                npc_mounted_championAI::DamageTaken(NULL, damage);
+                return;
+            }
 
-        uint32 uiFireBallTimer;
-        uint32 uiBlastWaveTimer;
-        uint32 uiHasteTimer;
-        uint32 uiPolymorphTimer;
+            if(defeated)
+            {
+                damage = 0;
+                return;
+            }
 
-        bool bDone;
-        bool bHome;
+            // Prevent damage from finishing hit and mark creature as defeated
+            if(damage >= me->GetHealth())
+            {
+                damage = 0;
+                defeated = true;
+                me->SetUnitMovementFlags(MOVEMENTFLAG_WALKING);
+                me->GetMotionMaster()->MovePoint(1, me->GetHomePosition());
+                me->SetTarget(0);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                BindPlayersToInstance(me);
+            }
+        }
 
-        void Reset()
+        void MovementInform(uint32 type, uint32 id)
         {
-            uiFireBallTimer = 5000;
-            uiPolymorphTimer  = 8000;
-            uiBlastWaveTimer = 12000;
-            uiHasteTimer = 22000;
+            // Knee at home position after being defeated
+            if(type == POINT_MOTION_TYPE && id == 1)
+                me->CastSpell(me, SPELL_KNEE, true);
         }
 
-        void JustReachedHome()
+        uint32 GetData(uint32 type)
         {
-            ScriptedAI::JustReachedHome();
-
-            if (!bHome)
-                return;
+            if (isInMountedGauntlet())
+                return npc_mounted_championAI::GetData(type);
 
-            uiPhaseTimer = 15000;
-            uiPhase = 1;
+            // Used by Announcer on periodic check of the bosses state
+            if(type == DATA_CHAMPION_DEFEATED)
+                return defeated ? 1 : 0;
 
-            bHome = false;
+            return 0;
         }
 
-        void UpdateAI(const uint32 uiDiff)
+        void EnterCombat(Unit* who)
         {
-            if (!bDone && GrandChampionsOutVehicle(me))
+            if (isInMountedGauntlet())
             {
-                bDone = true;
-
-                if (instance && me->GetGUID() == instance->GetData64(DATA_GRAND_CHAMPION_1))
-                    me->SetHomePosition(739.678f, 662.541f, 412.393f, 4.49f);
-                else if (instance && me->GetGUID() == instance->GetData64(DATA_GRAND_CHAMPION_2))
-                    me->SetHomePosition(746.71f, 661.02f, 411.69f, 4.6f);
-                else if (instance && me->GetGUID() == instance->GetData64(DATA_GRAND_CHAMPION_3))
-                    me->SetHomePosition(754.34f, 660.70f, 412.39f, 4.79f);
+                npc_mounted_championAI::EnterCombat(who);
+                return;
+            }
 
-                if (instance)
+            if(InstanceScript* instance = me->GetInstanceScript())
+                if(instance->GetData(BOSS_GRAND_CHAMPIONS) != IN_PROGRESS)
                     instance->SetData(BOSS_GRAND_CHAMPIONS, IN_PROGRESS);
+        };
 
-                EnterEvadeMode();
-                bHome = true;
+        void JustReachedHome()
+        {
+            if (isInMountedGauntlet())
+            {
+                npc_mounted_championAI::JustReachedHome();
+                return;
             }
 
-            if (uiPhaseTimer <= uiDiff)
-            {
-                if (uiPhase == 1)
-                {
-                    AggroAllPlayers(me);
-                    uiPhase = 0;
-                }
-            }else uiPhaseTimer -= uiDiff;
+            if(InstanceScript* instance = me->GetInstanceScript())
+                if(instance->GetData(BOSS_GRAND_CHAMPIONS) == IN_PROGRESS)
+                    instance->SetData(BOSS_GRAND_CHAMPIONS, FAIL);
+        }
 
-            if (uiFireBallTimer <= uiDiff)
+        void UpdateAI(const uint32 diff)
+        {
+            if (isInMountedGauntlet())
             {
-                if (me->getVictim())
-                    DoCastVictim(SPELL_FIREBALL);
-                uiFireBallTimer = 5000;
-            } else uiFireBallTimer -= uiDiff;
+                npc_mounted_championAI::UpdateAI(diff);
+                return;
+            }
 
-            if (!UpdateVictim() || me->HasUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT))
+            if (!UpdateVictim())
                 return;
 
-            if (uiFireBallTimer <= uiDiff)
-            {
-                DoCastVictim(SPELL_FIREBALL);
-                uiFireBallTimer = 5000;
-            } else uiFireBallTimer -= uiDiff;
+            if(defeated)
+                return;
+
+            if(me->HasUnitState(UNIT_STATE_CASTING))
+                return;
 
-            if (uiPolymorphTimer <= uiDiff)
+            if (polymorphTimer <= diff)
             {
                 if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0))
                     DoCast(target, SPELL_POLYMORPH);
-                uiPolymorphTimer = 8000;
-            } else uiPolymorphTimer -= uiDiff;
+                polymorphTimer = 8000;
+            } else polymorphTimer -= diff;
 
-            if (uiBlastWaveTimer <= uiDiff)
+            if (blastWaveTimer <= diff)
             {
                 DoCastAOE(SPELL_BLAST_WAVE, false);
-                uiBlastWaveTimer = 13000;
-            } else uiBlastWaveTimer -= uiDiff;
+                blastWaveTimer = 13000;
+            } else blastWaveTimer -= diff;
 
-            if (uiHasteTimer <= uiDiff)
+            if (hasteTimer <= diff)
             {
                 me->InterruptNonMeleeSpells(true);
 
                 DoCast(me, SPELL_HASTE);
-                uiHasteTimer = 22000;
-            } else uiHasteTimer -= uiDiff;
+                hasteTimer = 22000;
+            } else hasteTimer -= diff;
 
-            DoMeleeAttackIfReady();
-        }
+            if (fireBallTimer <= diff)
+            {
+                DoCastVictim(SPELL_FIREBALL);
+                fireBallTimer = 2600;
+            } else fireBallTimer -= diff;
 
-        void JustDied(Unit* /*killer*/)
-        {
-            if (instance)
-                instance->SetData(BOSS_GRAND_CHAMPIONS, DONE);
+            DoMeleeAttackIfReady();
         }
     };
 
@@ -578,139 +599,174 @@ public:
     boss_shaman_toc5() : CreatureScript("boss_shaman_toc5") { }
 
     // Colosos && Runok Wildmane || Shaman
-    struct boss_shaman_toc5AI : public ScriptedAI
+    struct boss_shaman_toc5AI : public npc_mounted_championAI
     {
-        boss_shaman_toc5AI(Creature* creature) : ScriptedAI(creature)
-        {
-            instance = creature->GetInstanceScript();
-
-            bDone = false;
-            bHome = false;
-
-            uiPhase = 0;
-            uiPhaseTimer = 0;
-
-            me->SetReactState(REACT_PASSIVE);
-            // THIS IS A HACK, SHOULD BE REMOVED WHEN THE EVENT IS FULL SCRIPTED
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
-        }
-
-        InstanceScript* instance;
-
-        uint8 uiPhase;
-        uint32 uiPhaseTimer;
+        boss_shaman_toc5AI(Creature* creature) : npc_mounted_championAI(creature) {}
 
-        uint32 uiChainLightningTimer;
-        uint32 uiEartShieldTimer;
-        uint32 uiHealingWaveTimer;
-        uint32 uiHexMendingTimer;
-
-        bool bDone;
-        bool bHome;
+        uint32 chainLightningTimer;
+        uint32 eartShieldTimer;
+        uint32 healingWaveTimer;
+        uint32 hexMendingTimer;
+        bool defeated;
 
         void Reset()
         {
-            uiChainLightningTimer = 16000;
-            uiHealingWaveTimer = 12000;
-            uiEartShieldTimer = urand(30000, 35000);
-            uiHexMendingTimer = urand(20000, 25000);
+            if (isInMountedGauntlet())
+            {
+                npc_mounted_championAI::Reset();
+                return;
+            }
+
+            defeated = false;
+            chainLightningTimer = 5000;
+            healingWaveTimer = 12000;
+            eartShieldTimer = urand(30000, 35000);
+            hexMendingTimer = urand(1000, 5000);
+            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            me->RemoveUnitMovementFlag(MOVEMENTFLAG_WALKING);
         }
 
         void EnterCombat(Unit* who)
         {
+            if (isInMountedGauntlet())
+            {
+                npc_mounted_championAI::EnterCombat(who);
+                return;
+            }
+
+            if(InstanceScript* instance = me->GetInstanceScript())
+                if(instance->GetData(BOSS_GRAND_CHAMPIONS) != IN_PROGRESS)
+                    instance->SetData(BOSS_GRAND_CHAMPIONS, IN_PROGRESS);
+
             DoCast(me, SPELL_EARTH_SHIELD);
-            DoCast(who, SPELL_HEX_OF_MENDING);
         };
 
         void JustReachedHome()
         {
-            ScriptedAI::JustReachedHome();
+            if (isInMountedGauntlet())
+            {
+                npc_mounted_championAI::JustReachedHome();
+                return;
+            }
 
-            if (!bHome)
+            if(InstanceScript* instance = me->GetInstanceScript())
+                if(instance->GetData(BOSS_GRAND_CHAMPIONS) == IN_PROGRESS)
+                    instance->SetData(BOSS_GRAND_CHAMPIONS, FAIL);
+        }
+
+        void DamageTaken(Unit* /*attacker*/, uint32 & damage)
+        {
+            if (isInMountedGauntlet())
+            {
+                npc_mounted_championAI::DamageTaken(NULL, damage);
                 return;
+            }
 
-            uiPhaseTimer = 15000;
-            uiPhase = 1;
+            if(defeated)
+            {
+                damage = 0;
+                return;
+            }
 
-            bHome = false;
+            // Prevent damage from finishing hit and mark creature as defeated
+            if(damage >= me->GetHealth())
+            {
+                damage = 0;
+                defeated = true;
+                me->SetUnitMovementFlags(MOVEMENTFLAG_WALKING);
+                me->GetMotionMaster()->MovePoint(1, me->GetHomePosition());
+                me->SetTarget(0);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                BindPlayersToInstance(me);
+            }
         }
 
-        void UpdateAI(const uint32 uiDiff)
+        void MovementInform(uint32 type, uint32 id)
         {
-            if (!bDone && GrandChampionsOutVehicle(me))
-            {
-                bDone = true;
+            // Knee at home position after being defeated
+            if(type == POINT_MOTION_TYPE && id == 1)
+                me->CastSpell(me, SPELL_KNEE, true);
+        }
 
-                if (instance && me->GetGUID() == instance->GetData64(DATA_GRAND_CHAMPION_1))
-                    me->SetHomePosition(739.678f, 662.541f, 412.393f, 4.49f);
-                else if (instance && me->GetGUID() == instance->GetData64(DATA_GRAND_CHAMPION_2))
-                    me->SetHomePosition(746.71f, 661.02f, 411.69f, 4.6f);
-                else if (instance && me->GetGUID() == instance->GetData64(DATA_GRAND_CHAMPION_3))
-                    me->SetHomePosition(754.34f, 660.70f, 412.39f, 4.79f);
+        uint32 GetData(uint32 type)
+        {
+            if (isInMountedGauntlet())
+                return npc_mounted_championAI::GetData(type);
 
-                if (instance)
-                    instance->SetData(BOSS_GRAND_CHAMPIONS, IN_PROGRESS);
+            // Used by Announcer on periodic check of the bosses state
+            if(type == DATA_CHAMPION_DEFEATED)
+                return defeated ? 1 : 0;
 
-                EnterEvadeMode();
-                bHome = true;
-            }
+            return 0;
+        }
 
-            if (uiPhaseTimer <= uiDiff)
+        void UpdateAI(const uint32 diff)
+        {
+            if (isInMountedGauntlet())
             {
-                if (uiPhase == 1)
-                {
-                    AggroAllPlayers(me);
-                    uiPhase = 0;
-                }
-            }else uiPhaseTimer -= uiDiff;
+                npc_mounted_championAI::UpdateAI(diff);
+                return;
+            }
 
-            if (!UpdateVictim() || me->HasUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT))
+            if (!UpdateVictim())
                 return;
 
-            if (uiChainLightningTimer <= uiDiff)
+            if(defeated)
+                return;
+
+            if(me->HasUnitState(UNIT_STATE_CASTING))
+                return;
+
+            if (chainLightningTimer <= diff)
             {
                 if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0))
                     DoCast(target, SPELL_CHAIN_LIGHTNING);
 
-                uiChainLightningTimer = 16000;
-            } else uiChainLightningTimer -= uiDiff;
+                chainLightningTimer = 8000;
+            } else chainLightningTimer -= diff;
 
-            if (uiHealingWaveTimer <= uiDiff)
+            if (healingWaveTimer <= diff)
             {
-                bool bChance = urand(0, 1);
+                bool chance = urand(0, 1);
 
-                if (!bChance)
+                if(!chance)
+                {
+                    if (Unit* friendUnit = DoSelectLowestHpFriendly(40))
+                    {
+                        DoCast(friendUnit, SPELL_HEALING_WAVE);
+                        healingWaveTimer = 5000;
+                    }
+                }else
                 {
-                    if (Unit* pFriend = DoSelectLowestHpFriendly(40))
-                        DoCast(pFriend, SPELL_HEALING_WAVE);
-                } else
                     DoCast(me, SPELL_HEALING_WAVE);
+                    healingWaveTimer = 8000;
+                }
+            } else healingWaveTimer -= diff;
 
-                uiHealingWaveTimer = 12000;
-            } else uiHealingWaveTimer -= uiDiff;
-
-            if (uiEartShieldTimer <= uiDiff)
+            if (eartShieldTimer <= diff)
             {
-                DoCast(me, SPELL_EARTH_SHIELD);
+                Unit* friendUnit = DoSelectLowestHpFriendly(40);
 
-                uiEartShieldTimer = urand(30000, 35000);
-            } else uiEartShieldTimer -= uiDiff;
+                if (friendUnit && friendUnit->HealthBelowPct(60) && !friendUnit->HasAura(SPELL_EARTH_SHIELD))
+                {
+                    DoCast(friendUnit, SPELL_EARTH_SHIELD);
+                    eartShieldTimer = urand(30000, 35000);
+                }else if(!me->HasAura(SPELL_EARTH_SHIELD))
+                {
+                    DoCast(me, SPELL_EARTH_SHIELD);
+                    eartShieldTimer = urand(30000, 35000);
+                } else eartShieldTimer = urand(1500, 3500);
+            } else eartShieldTimer -= diff;
 
-            if (uiHexMendingTimer <= uiDiff)
+            if (hexMendingTimer <= diff)
             {
                 DoCastVictim(SPELL_HEX_OF_MENDING, true);
 
-                uiHexMendingTimer = urand(20000, 25000);
-            } else uiHexMendingTimer -= uiDiff;
+                hexMendingTimer = urand(12000, 15000);
+            } else hexMendingTimer -= diff;
 
             DoMeleeAttackIfReady();
         }
-
-        void JustDied(Unit* /*killer*/)
-        {
-            if (instance)
-                instance->SetData(BOSS_GRAND_CHAMPIONS, DONE);
-        }
     };
 
     CreatureAI* GetAI(Creature* creature) const
@@ -724,148 +780,178 @@ class boss_hunter_toc5 : public CreatureScript
 public:
     boss_hunter_toc5() : CreatureScript("boss_hunter_toc5") { }
 
-        // Jaelyne Evensong && Zul'tore || Hunter
-    struct boss_hunter_toc5AI : public ScriptedAI
+    // Jaelyne Evensong && Zul'tore || Hunter
+    struct boss_hunter_toc5AI : public npc_mounted_championAI
     {
-        boss_hunter_toc5AI(Creature* creature) : ScriptedAI(creature)
-        {
-            instance = creature->GetInstanceScript();
+        boss_hunter_toc5AI(Creature* creature) : npc_mounted_championAI(creature) {}
 
-            bDone = false;
-            bHome = false;
+        uint32 multiShotTimer;
+        uint32 lightningArrowsTimer;
+        uint32 disengageTimer;
 
-            uiPhase = 0;
-            uiPhaseTimer = 0;
+        bool ligthingArrows;
+        bool defeated;
 
-            me->SetReactState(REACT_PASSIVE);
-            // THIS IS A HACK, SHOULD BE REMOVED WHEN THE EVENT IS FULL SCRIPTED
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
-        }
+        void Reset()
+        {
+            if (isInMountedGauntlet())
+            {
+                npc_mounted_championAI::Reset();
+                return;
+            }
 
-        InstanceScript* instance;
+            if(defeated)
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+
+            defeated = false;
+            ligthingArrows = false;
+            multiShotTimer = 2000;
+            disengageTimer = 3000;
+            lightningArrowsTimer = 7000;
+            me->SetSheath(SHEATH_STATE_RANGED);
+            me->SetStatFloatValue(UNIT_FIELD_MINRANGEDDAMAGE, IsHeroic() ? 5000.0f : 3000.0f);
+            me->SetStatFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE, IsHeroic() ? 6000.0f : 4000.0f);
+            me->RemoveUnitMovementFlag(MOVEMENTFLAG_WALKING);
+        }
 
-        uint8 uiPhase;
-        uint32 uiPhaseTimer;
+        void DamageTaken(Unit* /*attacker*/, uint32 & damage)
+        {
+            if (isInMountedGauntlet())
+            {
+                npc_mounted_championAI::DamageTaken(NULL, damage);
+                return;
+            }
 
-        uint32 uiShootTimer;
-        uint32 uiMultiShotTimer;
-        uint32 uiLightningArrowsTimer;
+            if(defeated)
+            {
+                damage = 0;
+                return;
+            }
 
-        uint64 uiTargetGUID;
+            // Prevent damage from finishing hit and mark creature as defeated
+            if(damage >= me->GetHealth())
+            {
+                damage = 0;
+                defeated = true;
+                me->SetUnitMovementFlags(MOVEMENTFLAG_WALKING);
+                me->GetMotionMaster()->MovePoint(1, me->GetHomePosition());
+                me->SetTarget(0);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                BindPlayersToInstance(me);
+            }
+        }
 
-        bool bShoot;
-        bool bDone;
-        bool bHome;
+        void MovementInform(uint32 type, uint32 id)
+        {
+            // Knee at home position after being defeated
+            if(type == POINT_MOTION_TYPE && id == 1)
+                me->CastSpell(me, SPELL_KNEE, true);
+        }
 
-        void Reset()
+        uint32 GetData(uint32 type)
         {
-            uiShootTimer = 12000;
-            uiMultiShotTimer = 0;
-            uiLightningArrowsTimer = 7000;
+            if (isInMountedGauntlet())
+                return npc_mounted_championAI::GetData(type);
 
-            uiTargetGUID = 0;
+            // Used by Announcer on periodic check of the bosses state
+            if(type == DATA_CHAMPION_DEFEATED)
+                return defeated ? 1 : 0;
 
-            bShoot = false;
+            return 0;
         }
 
-        void JustReachedHome()
+        void EnterCombat(Unit* who)
         {
-            ScriptedAI::JustReachedHome();
-
-            if (!bHome)
+            if (isInMountedGauntlet())
+            {
+                npc_mounted_championAI::EnterCombat(who);
                 return;
+            }
+
+            if(InstanceScript* instance = me->GetInstanceScript())
+                if(instance->GetData(BOSS_GRAND_CHAMPIONS) != IN_PROGRESS)
+                    instance->SetData(BOSS_GRAND_CHAMPIONS, IN_PROGRESS);
+        };
 
-            uiPhaseTimer = 15000;
-            uiPhase = 1;
+        void JustReachedHome()
+        {
+            if (isInMountedGauntlet())
+            {
+                npc_mounted_championAI::JustReachedHome();
+                return;
+            }
 
-            bHome = false;
+            if(InstanceScript* instance = me->GetInstanceScript())
+                if(instance->GetData(BOSS_GRAND_CHAMPIONS) == IN_PROGRESS)
+                    instance->SetData(BOSS_GRAND_CHAMPIONS, FAIL);
         }
 
-        void UpdateAI(const uint32 uiDiff)
+        void UpdateAI(const uint32 diff)
         {
-            if (!bDone && GrandChampionsOutVehicle(me))
+            if (isInMountedGauntlet())
             {
-                bDone = true;
+                npc_mounted_championAI::UpdateAI(diff);
+                return;
+            }
 
-                if (instance && me->GetGUID() == instance->GetData64(DATA_GRAND_CHAMPION_1))
-                    me->SetHomePosition(739.678f, 662.541f, 412.393f, 4.49f);
-                else if (instance && me->GetGUID() == instance->GetData64(DATA_GRAND_CHAMPION_2))
-                    me->SetHomePosition(746.71f, 661.02f, 411.69f, 4.6f);
-                else if (instance && me->GetGUID() == instance->GetData64(DATA_GRAND_CHAMPION_3))
-                    me->SetHomePosition(754.34f, 660.70f, 412.39f, 4.79f);
+            if (!UpdateVictim())
+                return;
 
-                if (instance)
-                    instance->SetData(BOSS_GRAND_CHAMPIONS, IN_PROGRESS);
+            if(defeated)
+                return;
 
-                EnterEvadeMode();
-                bHome = true;
-            }
+            if(me->HasUnitState(UNIT_STATE_CASTING))
+                return;
 
-            if (uiPhaseTimer <= uiDiff)
+            if(me->GetDistance(me->getVictim()) >= 30.0f)
+                me->GetMotionMaster()->MoveChase(me->getVictim(), 25.0f);
+
+            if (disengageTimer <= diff)
             {
-                if (uiPhase == 1)
+                if(me->GetDistance(me->getVictim()) <= 3.0f)
                 {
-                    AggroAllPlayers(me);
-                    uiPhase = 0;
+                    DoCast(SPELL_DISENGAGE);
+                    disengageTimer = 7000;
                 }
-            }else uiPhaseTimer -= uiDiff;
+                else disengageTimer = 1000;
+            } else disengageTimer -= diff;
 
-            if (!UpdateVictim() || me->HasUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT))
+            if (lightningArrowsTimer <= diff && !me->HasAura(SPELL_LIGHTNING_ARROWS))
+            {
+                DoCastAOE(SPELL_LIGHTNING_ARROWS_VISUAL, false);
+                lightningArrowsTimer = 14000;
+                ligthingArrows = true;
                 return;
+            } else lightningArrowsTimer -= diff;
 
-            if (uiLightningArrowsTimer <= uiDiff)
+            // Trigger the aura after the visual storm
+            if(ligthingArrows && !me->HasAura(SPELL_LIGHTNING_ARROWS_VISUAL))
             {
-                DoCastAOE(SPELL_LIGHTNING_ARROWS, false);
-                uiLightningArrowsTimer = 7000;
-            } else uiLightningArrowsTimer -= uiDiff;
+                DoCast(SPELL_LIGHTNING_ARROWS);
+                ligthingArrows = false;
+            }
 
-            if (uiShootTimer <= uiDiff)
+            if (multiShotTimer <= diff)
             {
-                if (Unit* target = SelectTarget(SELECT_TARGET_FARTHEST, 0, 30.0f))
-                {
-                    uiTargetGUID = target->GetGUID();
-                    DoCast(target, SPELL_SHOOT);
-                }
-                uiShootTimer = 12000;
-                uiMultiShotTimer = 3000;
-                bShoot = true;
-            } else uiShootTimer -= uiDiff;
+                if(Unit* target = SelectTarget(SELECT_TARGET_FARTHEST))
+                    if(target->IsInRange(me, 5.0f, 35.0f))
+                    {
+                        DoCast(target, SPELL_MULTI_SHOT);
+                        multiShotTimer = 6000;
+                    } else multiShotTimer = 1000;
+            } else multiShotTimer -= diff;
 
-            if (bShoot && uiMultiShotTimer <= uiDiff)
+            // Shoot instead of meele swing
+            if (me->isAttackReady())
             {
-                me->InterruptNonMeleeSpells(true);
-                Unit* target = Unit::GetUnit(*me, uiTargetGUID);
-
-                if (target && me->IsInRange(target, 5.0f, 30.0f, false))
-                {
-                    DoCast(target, SPELL_MULTI_SHOT);
-                }
-                else
+                if(Aura* lArrows = me->GetAura(SPELL_LIGHTNING_ARROWS))
                 {
-                    Map::PlayerList const& players = me->GetMap()->GetPlayers();
-                    if (me->GetMap()->IsDungeon() && !players.isEmpty())
-                    {
-                        for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
-                        {
-                            Player* player = itr->getSource();
-                            if (player && !player->isGameMaster() && me->IsInRange(player, 5.0f, 30.0f, false))
-                            {
-                                DoCast(player, SPELL_MULTI_SHOT);
-                                break;
-                            }
-                        }
-                    }
+                    DoCast(me->getVictim(), SPELL_LIGHTNING_ARROWS_DAMAGE, true);
+                    lArrows->ModCharges(-1);
                 }
-                bShoot = false;
-            } else uiMultiShotTimer -= uiDiff;
-
-            DoMeleeAttackIfReady();
-        }
-
-        void JustDied(Unit* /*killer*/)
-        {
-            if (instance)
-                instance->SetData(BOSS_GRAND_CHAMPIONS, DONE);
+                DoCast(me->getVictim(), SPELL_SHOOT, true);
+                me->resetAttackTimer();
+            }
         }
     };
 
@@ -881,113 +967,149 @@ public:
     boss_rouge_toc5() : CreatureScript("boss_rouge_toc5") { }
 
     // Lana Stouthammer Evensong && Deathstalker Visceri || Rouge
-    struct boss_rouge_toc5AI : public ScriptedAI
+    struct boss_rouge_toc5AI : public npc_mounted_championAI
     {
-        boss_rouge_toc5AI(Creature* creature) : ScriptedAI(creature)
+        boss_rouge_toc5AI(Creature* creature) : npc_mounted_championAI(creature) {}
+
+        uint32 eviscerateTimer;
+        uint32 fanKivesTimer;
+        uint32 posionBottleTimer;
+
+        bool defeated;
+
+        void Reset()
         {
-            instance = creature->GetInstanceScript();
+            if (isInMountedGauntlet())
+            {
+                npc_mounted_championAI::Reset();
+                return;
+            }
 
-            bDone = false;
-            bHome = false;
+            if(defeated)
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
 
-            uiPhase = 0;
-            uiPhaseTimer = 0;
+            defeated = false;
+            eviscerateTimer = 8000;
+            fanKivesTimer   = 14000;
+            posionBottleTimer = 19000;
 
-            me->SetReactState(REACT_PASSIVE);
-            // THIS IS A HACK, SHOULD BE REMOVED WHEN THE EVENT IS FULL SCRIPTED
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
+            // Settings for offhand attack
+            DoCast(me, SPELL_DUAL_WIELD, true);
+            me->SetAttackTime(OFF_ATTACK, 1400);
+            me->SetStatFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE, IsHeroic() ? 5000.0f : 3000.0f);
+            me->SetStatFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE, IsHeroic() ? 6000.0f : 4000.0f);
+            me->RemoveUnitMovementFlag(MOVEMENTFLAG_WALKING);
         }
 
-        InstanceScript* instance;
+        void DamageTaken(Unit* /*attacker*/, uint32 & damage)
+        {
+            if (isInMountedGauntlet())
+            {
+                npc_mounted_championAI::DamageTaken(NULL, damage);
+                return;
+            }
 
-        uint8 uiPhase;
-        uint32 uiPhaseTimer;
-        uint32 uiEviscerateTimer;
-        uint32 uiFanKivesTimer;
-        uint32 uiPosionBottleTimer;
+            if(defeated)
+            {
+                damage = 0;
+                return;
+            }
 
-        bool bDone;
-        bool bHome;
+            // Prevent damage from finishing hit and mark creature as defeated
+            if(damage >= me->GetHealth())
+            {
+                damage = 0;
+                defeated = true;
+                me->SetUnitMovementFlags(MOVEMENTFLAG_WALKING);
+                me->GetMotionMaster()->MovePoint(1, me->GetHomePosition());
+                me->SetTarget(0);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                BindPlayersToInstance(me);
+            }
+        }
 
-        void Reset()
+        void MovementInform(uint32 type, uint32 id)
         {
-            uiEviscerateTimer = 8000;
-            uiFanKivesTimer   = 14000;
-            uiPosionBottleTimer = 19000;
+            // Knee at home position after being defeated
+            if(type == POINT_MOTION_TYPE && id == 1)
+                me->CastSpell(me, SPELL_KNEE, true);
         }
 
-        void JustReachedHome()
+        uint32 GetData(uint32 type)
         {
-            ScriptedAI::JustReachedHome();
+            if (isInMountedGauntlet())
+                return npc_mounted_championAI::GetData(type);
 
-            if (!bHome)
-                return;
-
-            uiPhaseTimer = 15000;
-            uiPhase = 1;
+            // Used by Announcer on periodic check of the bosses state
+            if(type == DATA_CHAMPION_DEFEATED)
+                return defeated ? 1 : 0;
 
-            bHome = false;
+            return 0;
         }
 
-        void UpdateAI(const uint32 uiDiff)
+        void EnterCombat(Unit* who)
         {
-            if (!bDone && GrandChampionsOutVehicle(me))
+            if (isInMountedGauntlet())
             {
-                bDone = true;
-
-                if (instance && me->GetGUID() == instance->GetData64(DATA_GRAND_CHAMPION_1))
-                    me->SetHomePosition(739.678f, 662.541f, 412.393f, 4.49f);
-                else if (instance && me->GetGUID() == instance->GetData64(DATA_GRAND_CHAMPION_2))
-                    me->SetHomePosition(746.71f, 661.02f, 411.69f, 4.6f);
-                else if (instance && me->GetGUID() == instance->GetData64(DATA_GRAND_CHAMPION_3))
-                    me->SetHomePosition(754.34f, 660.70f, 412.39f, 4.79f);
+                npc_mounted_championAI::EnterCombat(who);
+                return;
+            }
 
-                if (instance)
+            if(InstanceScript* instance = me->GetInstanceScript())
+                if(instance->GetData(BOSS_GRAND_CHAMPIONS) != IN_PROGRESS)
                     instance->SetData(BOSS_GRAND_CHAMPIONS, IN_PROGRESS);
 
-                EnterEvadeMode();
-                bHome = true;
+            DoCast(me, SPELL_DEADLY_POISON);
+        };
+
+        void JustReachedHome()
+        {
+            if (isInMountedGauntlet())
+            {
+                npc_mounted_championAI::JustReachedHome();
+                return;
             }
 
-            if (uiPhaseTimer <= uiDiff)
+            if(InstanceScript* instance = me->GetInstanceScript())
+                if(instance->GetData(BOSS_GRAND_CHAMPIONS) == IN_PROGRESS)
+                    instance->SetData(BOSS_GRAND_CHAMPIONS, FAIL);
+        }
+
+        void UpdateAI(const uint32 diff)
+        {
+            if (isInMountedGauntlet())
             {
-                if (uiPhase == 1)
-                {
-                    AggroAllPlayers(me);
-                    uiPhase = 0;
-                }
-            } else uiPhaseTimer -= uiDiff;
+                npc_mounted_championAI::UpdateAI(diff);
+                return;
+            }
+
+            if (!UpdateVictim())
+                return;
 
-            if (!UpdateVictim() || me->HasUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT))
+            if(defeated)
                 return;
 
-            if (uiEviscerateTimer <= uiDiff)
+            if (eviscerateTimer <= diff)
             {
                 DoCast(me->getVictim(), SPELL_EVISCERATE);
-                uiEviscerateTimer = 8000;
-            } else uiEviscerateTimer -= uiDiff;
+                eviscerateTimer = 8000;
+            } else eviscerateTimer -= diff;
 
-            if (uiFanKivesTimer <= uiDiff)
+            if (fanKivesTimer <= diff)
             {
                 DoCastAOE(SPELL_FAN_OF_KNIVES, false);
-                uiFanKivesTimer = 14000;
-            } else uiFanKivesTimer -= uiDiff;
+                fanKivesTimer = 14000;
+            } else fanKivesTimer -= diff;
 
-            if (uiPosionBottleTimer <= uiDiff)
+            if (posionBottleTimer <= diff)
             {
                 if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0))
                     DoCast(target, SPELL_POISON_BOTTLE);
-                uiPosionBottleTimer = 19000;
-            } else uiPosionBottleTimer -= uiDiff;
+                posionBottleTimer = 19000;
+            } else posionBottleTimer -= diff;
 
             DoMeleeAttackIfReady();
         }
-
-        void JustDied(Unit* /*killer*/)
-        {
-            if (instance)
-                instance->SetData(BOSS_GRAND_CHAMPIONS, DONE);
-        }
     };
 
     CreatureAI* GetAI(Creature* creature) const
@@ -996,6 +1118,201 @@ public:
     }
 };
 
+enum vehicleSpells
+{
+    // Defend
+    SPELL_DEFEND          = 66482,
+    SPELL_VISUAL_SHIELD_1 = 63130,
+    SPELL_VISUAL_SHIELD_2 = 63131,
+    SPELL_VISUAL_SHIELD_3 = 63132,
+
+    // Shield break
+    SPELL_THROW_VISUAL    = 45827,
+};
+
+class spell_toc5_ride_mount : public SpellScriptLoader
+{
+    public:
+        spell_toc5_ride_mount() : SpellScriptLoader("spell_toc5_ride_mount") {}
+
+        class spell_toc5_ride_mount_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_toc5_ride_mount_SpellScript);
+
+            SpellCastResult CheckRequirement()
+            {
+                if(GetCaster()->GetUInt32Value(PLAYER_VISIBLE_ITEM_16_ENTRYID) == 46106 ||
+                    GetCaster()->GetUInt32Value(PLAYER_VISIBLE_ITEM_16_ENTRYID) == 46069 ||
+                    GetCaster()->GetUInt32Value(PLAYER_VISIBLE_ITEM_16_ENTRYID) == 46070)
+                {
+                    GetCaster()->RemoveAurasByType(SPELL_AURA_MOD_SHAPESHIFT);
+                    return SPELL_CAST_OK;
+                } else {
+                    SetCustomCastResultMessage(SPELL_CUSTOM_ERROR_MUST_HAVE_LANCE_EQUIPPED);
+                    return SPELL_FAILED_CUSTOM_ERROR;
+                }
+            }
+
+            void Register()
+            {
+                OnCheckCast += SpellCheckCastFn(spell_toc5_ride_mount_SpellScript::CheckRequirement);
+            }
+        };
+
+        class spell_toc5_ride_mount_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_toc5_ride_mount_AuraScript);
+
+            void HandleOnEffect(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
+            {
+                if (Unit* target = GetTarget())
+                    target->RemoveAurasDueToSpell(SPELL_DEFEND);
+                if (Unit* caster = GetCaster())
+                {
+                    caster->RemoveAurasDueToSpell(SPELL_DEFEND);
+                    for (uint8 i=0; i<3; i++)
+                        caster->RemoveAurasDueToSpell(SPELL_VISUAL_SHIELD_1+i);
+                }
+            }
+
+            void Register()
+            {
+                OnEffectApply += AuraEffectApplyFn(spell_toc5_ride_mount_AuraScript::HandleOnEffect, EFFECT_0, SPELL_AURA_CONTROL_VEHICLE, AURA_EFFECT_HANDLE_REAL_OR_REAPPLY_MASK);
+                OnEffectRemove += AuraEffectRemoveFn(spell_toc5_ride_mount_AuraScript::HandleOnEffect, EFFECT_0, SPELL_AURA_CONTROL_VEHICLE, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_toc5_ride_mount_AuraScript();
+        }
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_toc5_ride_mount_SpellScript();
+        }
+};
+
+class spell_toc5_defend : public SpellScriptLoader
+{
+    public:
+        spell_toc5_defend() : SpellScriptLoader("spell_toc5_defend") { }
+
+        class spell_toc5_defendAuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_toc5_defendAuraScript);
+
+            bool Validate(SpellInfo const* /*spellEntry*/)
+            {
+                if (!sSpellMgr->GetSpellInfo(SPELL_VISUAL_SHIELD_1))
+                    return false;
+                if (!sSpellMgr->GetSpellInfo(SPELL_VISUAL_SHIELD_2))
+                    return false;
+                if (!sSpellMgr->GetSpellInfo(SPELL_VISUAL_SHIELD_3))
+                    return false;
+                return true;
+            }
+
+            void RefreshVisualShields(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
+            {
+                Unit* caster = GetCaster();
+
+                if(!caster)
+                    return;
+
+                if(Unit* rider = caster->GetCharmer())
+                {
+                    for(uint8 i=0; i < 3; ++i)
+                        rider->RemoveAurasDueToSpell(SPELL_VISUAL_SHIELD_1 + i);
+
+                    if(Aura* defend = caster->GetAura(GetId()))
+                        rider->CastSpell(rider, SPELL_VISUAL_SHIELD_1 + (defend->GetStackAmount()-1), true);
+                }else
+                {
+                    for(uint8 i=0; i < 3; ++i)
+                        caster->RemoveAurasDueToSpell(SPELL_VISUAL_SHIELD_1 + i);
+
+                    if(Aura* defend = caster->GetAura(GetId()))
+                        caster->CastSpell(caster, SPELL_VISUAL_SHIELD_1 + (defend->GetStackAmount()-1), true);
+                }
+            }
+
+            void Register()
+            {
+                OnEffectApply += AuraEffectApplyFn(spell_toc5_defendAuraScript::RefreshVisualShields, EFFECT_FIRST_FOUND, SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, AURA_EFFECT_HANDLE_CHANGE_AMOUNT_SEND_FOR_CLIENT_MASK);
+                OnEffectRemove += AuraEffectRemoveFn(spell_toc5_defendAuraScript::RefreshVisualShields, EFFECT_FIRST_FOUND, SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, AURA_EFFECT_HANDLE_CHANGE_AMOUNT_SEND_FOR_CLIENT_MASK);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_toc5_defendAuraScript();
+        }
+};
+
+class player_hex_mendingAI : public PlayerAI
+{
+    public:
+        player_hex_mendingAI(Player* player) : PlayerAI(player) {}
+
+        void HealReceived(Unit* healer, uint32 & addHealth)
+        {
+            PlayerAI::HealReceived(healer, addHealth);
+            me->CastCustomSpell(SPELL_HEX_OF_MENDING_HEAL, SPELLVALUE_BASE_POINT0, int32(addHealth*2.0f), me, true);
+        }
+
+        void UpdateAI(const uint32 /*diff*/) { }
+
+    private:
+        uint64 casterGUID;
+};
+
+class spell_toc5_hex_mending : public SpellScriptLoader
+{
+    public:
+        spell_toc5_hex_mending() : SpellScriptLoader("spell_toc5_hex_mending") { }
+
+        class spell_toc5_hex_mending_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_toc5_hex_mending_AuraScript);
+
+            void OnApply(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
+            {
+                if (GetTarget()->GetTypeId() != TYPEID_PLAYER)
+                    return;
+
+                oldAI = GetTarget()->GetAI();
+                GetTarget()->SetAI(new player_hex_mendingAI(GetTarget()->ToPlayer()));
+                oldAIState = GetTarget()->IsAIEnabled;
+                GetTarget()->IsAIEnabled = true;
+            }
+
+            void OnRemove(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
+            {
+                if (GetTarget()->GetTypeId() != TYPEID_PLAYER)
+                    return;
+
+                delete GetTarget()->GetAI();
+                GetTarget()->SetAI(oldAI);
+                GetTarget()->IsAIEnabled = oldAIState;
+            }
+
+            void Register()
+            {
+                AfterEffectApply += AuraEffectApplyFn(spell_toc5_hex_mending_AuraScript::OnApply, EFFECT_0, SPELL_AURA_DUMMY, AURA_EFFECT_HANDLE_REAL);
+                AfterEffectRemove += AuraEffectRemoveFn(spell_toc5_hex_mending_AuraScript::OnRemove, EFFECT_0, SPELL_AURA_DUMMY, AURA_EFFECT_HANDLE_REAL);
+            }
+
+            UnitAI* oldAI;
+            bool oldAIState;
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_toc5_hex_mending_AuraScript();
+        }
+};
+
 void AddSC_boss_grand_champions()
 {
     new generic_vehicleAI_toc5();
@@ -1004,4 +1321,7 @@ void AddSC_boss_grand_champions()
     new boss_shaman_toc5();
     new boss_hunter_toc5();
     new boss_rouge_toc5();
+    new spell_toc5_ride_mount();
+    new spell_toc5_defend();
+    new spell_toc5_hex_mending();
 }
diff --git a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/instance_trial_of_the_champion.cpp b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/instance_trial_of_the_champion.cpp
index 9ccd136..41fdb8b 100644
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/instance_trial_of_the_champion.cpp
+++ b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/instance_trial_of_the_champion.cpp
@@ -17,7 +17,6 @@
 
 /* ScriptData
 SDName: Instance Trial of the Champion
-SDComment:
 SDCategory: Trial Of the Champion
 EndScriptData */
 
@@ -31,59 +30,56 @@ class instance_trial_of_the_champion : public InstanceMapScript
 public:
     instance_trial_of_the_champion() : InstanceMapScript("instance_trial_of_the_champion", 650) { }
 
-    InstanceScript* GetInstanceScript(InstanceMap* map) const
+    InstanceScript* GetInstanceScript(InstanceMap* pMap) const
     {
-        return new instance_trial_of_the_champion_InstanceMapScript(map);
+        return new instance_trial_of_the_champion_InstanceMapScript(pMap);
     }
 
     struct instance_trial_of_the_champion_InstanceMapScript : public InstanceScript
     {
-        instance_trial_of_the_champion_InstanceMapScript(Map* map) : InstanceScript(map) {}
+        instance_trial_of_the_champion_InstanceMapScript(Map* pMap) : InstanceScript(pMap) {}
 
         uint32 m_auiEncounter[MAX_ENCOUNTER];
-
-        uint16 uiMovementDone;
-        uint16 uiGrandChampionsDeaths;
-        uint8 uiArgentSoldierDeaths;
+        uint32 grandChampionEntry[3];
+        uint32 memoryEntry;
 
         uint64 uiAnnouncerGUID;
+        uint64 uiTirionGUID;
+        uint64 uiThrallGUID;
+        uint64 uiGarroshGUID;
+        uint64 uiVarianGUID;
+        uint64 uiJainaGUID;
+        uint64 grandChampionGUID[3];
+        uint64 uiBlackKnightGUID;
+        uint64 uiBlackKnightGryphonGUID;
         uint64 uiMainGateGUID;
-        uint64 uiGrandChampionVehicle1GUID;
-        uint64 uiGrandChampionVehicle2GUID;
-        uint64 uiGrandChampionVehicle3GUID;
-        uint64 uiGrandChampion1GUID;
-        uint64 uiGrandChampion2GUID;
-        uint64 uiGrandChampion3GUID;
+        uint64 uiPortcullisGUID;
         uint64 uiChampionLootGUID;
-        uint64 uiArgentChampionGUID;
 
         std::list<uint64> VehicleList;
+        uint32 TeamInInstance;
 
-        std::string str_data;
-
-        bool bDone;
+        bool achievementHadWorse;
 
         void Initialize()
         {
-            uiMovementDone = 0;
-            uiGrandChampionsDeaths = 0;
-            uiArgentSoldierDeaths = 0;
-
             uiAnnouncerGUID        = 0;
+            uiTirionGUID           = 0;
+            uiThrallGUID           = 0;
+            uiGarroshGUID          = 0;
+            uiJainaGUID            = 0;
             uiMainGateGUID         = 0;
-            uiGrandChampionVehicle1GUID   = 0;
-            uiGrandChampionVehicle2GUID   = 0;
-            uiGrandChampionVehicle3GUID   = 0;
-            uiGrandChampion1GUID          = 0;
-            uiGrandChampion2GUID          = 0;
-            uiGrandChampion3GUID          = 0;
-            uiChampionLootGUID            = 0;
-            uiArgentChampionGUID          = 0;
+            uiPortcullisGUID       = 0;
+            uiChampionLootGUID     = 0;
+            memoryEntry            = 0;
+            uiBlackKnightGUID      = 0;
 
-            bDone = false;
+            achievementHadWorse = true;
 
             VehicleList.clear();
-
+            TeamInInstance = 0;
+            memset(&grandChampionEntry, 0, sizeof(grandChampionEntry));
+            memset(&grandChampionEntry, 0, sizeof(grandChampionGUID));
             memset(&m_auiEncounter, 0, sizeof(m_auiEncounter));
         }
 
@@ -98,10 +94,15 @@ public:
             return false;
         }
 
+        void OnPlayerEnter(Player* player)
+        {
+            if (!TeamInInstance)
+                TeamInInstance = player->GetTeam();
+        }
+
         void OnCreatureCreate(Creature* creature)
         {
             Map::PlayerList const &players = instance->GetPlayers();
-            uint32 TeamInInstance = 0;
 
             if (!players.isEmpty())
             {
@@ -109,176 +110,330 @@ public:
                     TeamInInstance = player->GetTeam();
             }
 
-            switch (creature->GetEntry())
+            switch(creature->GetEntry())
             {
-                // Champions
-                case VEHICLE_MOKRA_SKILLCRUSHER_MOUNT:
-                    if (TeamInInstance == HORDE)
-                        creature->UpdateEntry(VEHICLE_MARSHAL_JACOB_ALERIUS_MOUNT, ALLIANCE);
+                // Coliseum Announcer || Only NPC_JAEREN must be spawned.
+                case NPC_JAEREN:
+                    if (TeamInInstance == ALLIANCE)
+                        creature->UpdateEntry(NPC_ARELAS);
+                    uiAnnouncerGUID = creature->GetGUID();
                     break;
-                case VEHICLE_ERESSEA_DAWNSINGER_MOUNT:
-                    if (TeamInInstance == HORDE)
-                        creature->UpdateEntry(VEHICLE_AMBROSE_BOLTSPARK_MOUNT, ALLIANCE);
+                case NPC_TIRION:
+                    uiTirionGUID = creature->GetGUID();
                     break;
-                case VEHICLE_RUNOK_WILDMANE_MOUNT:
-                    if (TeamInInstance == HORDE)
-                        creature->UpdateEntry(VEHICLE_COLOSOS_MOUNT, ALLIANCE);
+                case NPC_THRALL:
+                    uiThrallGUID = creature->GetGUID();
                     break;
-                case VEHICLE_ZUL_TORE_MOUNT:
-                    if (TeamInInstance == HORDE)
-                        creature->UpdateEntry(VEHICLE_EVENSONG_MOUNT, ALLIANCE);
+                case NPC_GARROSH:
+                    uiGarroshGUID = creature->GetGUID();
                     break;
-                case VEHICLE_DEATHSTALKER_VESCERI_MOUNT:
-                    if (TeamInInstance == HORDE)
-                        creature->UpdateEntry(VEHICLE_LANA_STOUTHAMMER_MOUNT, ALLIANCE);
+                case NPC_VARIAN:
+                    uiVarianGUID = creature->GetGUID();
                     break;
-                // Coliseum Announcer || Just NPC_JAEREN must be spawned.
-                case NPC_JAEREN:
-                    uiAnnouncerGUID = creature->GetGUID();
-                    if (TeamInInstance == ALLIANCE)
-                        creature->UpdateEntry(NPC_ARELAS, ALLIANCE);
+                case NPC_JAINA:
+                    uiJainaGUID = creature->GetGUID();
                     break;
                 case VEHICLE_ARGENT_WARHORSE:
                 case VEHICLE_ARGENT_BATTLEWORG:
                     VehicleList.push_back(creature->GetGUID());
                     break;
-                case NPC_EADRIC:
-                case NPC_PALETRESS:
-                    uiArgentChampionGUID = creature->GetGUID();
+                case NPC_BLACK_KNIGHT:
+                    creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                    creature->SetReactState(REACT_PASSIVE);
+                    uiBlackKnightGUID = creature->GetGUID();
+                    break;
+                case VEHICLE_BLACK_KNIGHT:
+                    uiBlackKnightGryphonGUID = creature->GetGUID();
+                    creature->SetPhaseMask(2, true);
                     break;
             }
         }
 
         void OnGameObjectCreate(GameObject* go)
         {
-            switch (go->GetEntry())
+            switch(go->GetEntry())
             {
                 case GO_MAIN_GATE:
                     uiMainGateGUID = go->GetGUID();
                     break;
+                case GO_PORTCULLIS:
+                    uiPortcullisGUID = go->GetGUID();
+                    break;
                 case GO_CHAMPIONS_LOOT:
                 case GO_CHAMPIONS_LOOT_H:
+                case GO_EADRIC_LOOT:
+                case GO_EADRIC_LOOT_H:
+                case GO_PALETRESS_LOOT:
+                case GO_PALETRESS_LOOT_H:
                     uiChampionLootGUID = go->GetGUID();
                     break;
             }
         }
 
-        void SetData(uint32 uiType, uint32 uiData)
+        void SetData(uint32 type, uint32 data)
         {
-            switch (uiType)
+            switch(type)
             {
-                case DATA_MOVEMENT_DONE:
-                    uiMovementDone = uiData;
-                    if (uiMovementDone == 3)
-                    {
-                        if (Creature* pAnnouncer =  instance->GetCreature(uiAnnouncerGUID))
-                            pAnnouncer->AI()->SetData(DATA_IN_POSITION, 0);
-                    }
-                    break;
                 case BOSS_GRAND_CHAMPIONS:
-                    m_auiEncounter[0] = uiData;
-                    if (uiData == IN_PROGRESS)
+                    m_auiEncounter[0] = data;
+                    if (data == SPECIAL)
                     {
                         for (std::list<uint64>::const_iterator itr = VehicleList.begin(); itr != VehicleList.end(); ++itr)
                             if (Creature* summon = instance->GetCreature(*itr))
                                 summon->RemoveFromWorld();
-                    }else if (uiData == DONE)
+                    } else if (data == IN_PROGRESS)
+                    {
+                        for (uint8 i=0; i<3; i++)
+                            if (Creature* boss = instance->GetCreature(grandChampionGUID[i]))
+                                AggroAllPlayers(boss);
+                    } else if (data == DONE)
                     {
-                        ++uiGrandChampionsDeaths;
-                        if (uiGrandChampionsDeaths == 3)
+                        DoUpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, SPELL_ACHIEVEMENT_CHAMPIONS);
+                        if (Creature* announcer =  instance->GetCreature(uiAnnouncerGUID))
                         {
-                            if (Creature* pAnnouncer =  instance->GetCreature(uiAnnouncerGUID))
-                            {
-                                pAnnouncer->GetMotionMaster()->MovePoint(0, 748.309f, 619.487f, 411.171f);
-                                pAnnouncer->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
-                                pAnnouncer->SummonGameObject(instance->IsHeroic()? GO_CHAMPIONS_LOOT_H : GO_CHAMPIONS_LOOT, 746.59f, 618.49f, 411.09f, 1.42f, 0, 0, 0, 0, 90000000);
-                            }
+                            announcer->GetMotionMaster()->MovePoint(0, 742.742f, 630.207f, 411.172f);
+                            announcer->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+                            announcer->SummonGameObject(instance->IsHeroic()? GO_CHAMPIONS_LOOT_H : GO_CHAMPIONS_LOOT, 746.59f, 618.49f, 411.09f, 1.42f, 0, 0, 0, 0, 90000000);
                         }
                     }
                     break;
-                case DATA_ARGENT_SOLDIER_DEFEATED:
-                    uiArgentSoldierDeaths = uiData;
-                    if (uiArgentSoldierDeaths == 9)
+                case BOSS_ARGENT_CHALLENGE_E:
+                    m_auiEncounter[1] = data;
+                    if (data == DONE)
                     {
-                        if (Creature* pBoss =  instance->GetCreature(uiArgentChampionGUID))
+                        if (Creature* announcer = instance->GetCreature(uiAnnouncerGUID))
                         {
-                            pBoss->GetMotionMaster()->MovePoint(0, 746.88f, 618.74f, 411.06f);
-                            pBoss->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-                            pBoss->SetReactState(REACT_AGGRESSIVE);
+                            DoUpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, SPELL_ACHIEVEMENT_EADRIC);
+                            announcer->GetMotionMaster()->MovePoint(0, 742.742f, 630.207f, 411.172f);
+                            announcer->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+                            announcer->SummonGameObject(instance->IsHeroic()? GO_EADRIC_LOOT_H : GO_EADRIC_LOOT, 746.59f, 618.49f, 411.09f, 1.42f, 0, 0, 0, 0, 90000000);
                         }
                     }
                     break;
-                case BOSS_ARGENT_CHALLENGE_E:
-                    m_auiEncounter[1] = uiData;
-                    if (Creature* pAnnouncer = instance->GetCreature(uiAnnouncerGUID))
+                case BOSS_ARGENT_CHALLENGE_P:
+                    m_auiEncounter[2] = data;
+                    if (data == DONE)
                     {
-                        pAnnouncer->GetMotionMaster()->MovePoint(0, 748.309f, 619.487f, 411.171f);
-                        pAnnouncer->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
-                        pAnnouncer->SummonGameObject(instance->IsHeroic()? GO_EADRIC_LOOT_H : GO_EADRIC_LOOT, 746.59f, 618.49f, 411.09f, 1.42f, 0, 0, 0, 0, 90000000);
+                        if (Creature* announcer = instance->GetCreature(uiAnnouncerGUID))
+                        {
+                            DoUpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, SPELL_ACHIEVEMENT_PALETRESS);
+                            DoUpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, SPELL_ACHIEVEMENT_MEMORIES);
+                            announcer->GetMotionMaster()->MovePoint(0, 742.742f, 630.207f, 411.172f);
+                            announcer->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+                            announcer->SummonGameObject(instance->IsHeroic()? GO_PALETRESS_LOOT_H : GO_PALETRESS_LOOT, 746.59f, 618.49f, 411.09f, 1.42f, 0, 0, 0, 0, 90000000);
+                        }
                     }
                     break;
-                case BOSS_ARGENT_CHALLENGE_P:
-                    m_auiEncounter[2] = uiData;
-                    if (Creature* pAnnouncer = instance->GetCreature(uiAnnouncerGUID))
+                case BOSS_BLACK_KNIGHT:
+                    m_auiEncounter[3] = data;
+                    if (data == DONE)
+                        DoUpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, SPELL_ACHIEVEMENT_BLACK_KNIGHT);
+                    break;
+                case DATA_GRAND_CHAMPION_ENTRY:
+                    for (uint8 i=0; i<3; i++)
                     {
-                        pAnnouncer->GetMotionMaster()->MovePoint(0, 748.309f, 619.487f, 411.171f);
-                        pAnnouncer->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
-                        pAnnouncer->SummonGameObject(instance->IsHeroic()? GO_PALETRESS_LOOT_H : GO_PALETRESS_LOOT, 746.59f, 618.49f, 411.09f, 1.42f, 0, 0, 0, 0, 90000000);
+                        if (grandChampionEntry[i] == 0)
+                        {
+                            grandChampionEntry[i] = data;
+                            return;
+                        }
                     }
                     break;
+                case DATA_MEMORY_ENTRY:
+                    memoryEntry = data;
+                    break;
+                case DATA_I_VE_HAD_WORSE:
+                    achievementHadWorse = (bool)data;
+                    break;
             }
 
-            if (uiData == DONE)
-                SaveToDB();
+            if (type != DATA_I_VE_HAD_WORSE)
+            {
+                if (data == DONE || data == FAIL)
+                    HandleGameObject(GetData64(DATA_PORTCULLIS), true);
+                else if (data == IN_PROGRESS)
+                    HandleGameObject(GetData64(DATA_PORTCULLIS), false);
+
+                if (data == DONE)
+                    SaveToDB();
+            }
         }
 
-        uint32 GetData(uint32 uiData)
+        uint32 GetData(uint32 data)
         {
-            switch (uiData)
+            switch(data)
             {
                 case BOSS_GRAND_CHAMPIONS:  return m_auiEncounter[0];
                 case BOSS_ARGENT_CHALLENGE_E: return m_auiEncounter[1];
                 case BOSS_ARGENT_CHALLENGE_P: return m_auiEncounter[2];
                 case BOSS_BLACK_KNIGHT: return m_auiEncounter[3];
 
-                case DATA_MOVEMENT_DONE: return uiMovementDone;
-                case DATA_ARGENT_SOLDIER_DEFEATED: return uiArgentSoldierDeaths;
+                case DATA_TEAM: return TeamInInstance;
             }
 
             return 0;
         }
 
-        uint64 GetData64(uint32 uiData)
+        void SetData64(uint32 type, uint64 data)
+        {
+            switch (type)
+            {
+                case DATA_GRAND_CHAMPION_GUID:
+                    for (uint8 i=0; i<3; i++)
+                    {
+                        if (grandChampionGUID[i] == 0)
+                        {
+                            grandChampionGUID[i] = data;
+                            return;
+                        }
+                    }
+                    break;
+            }
+        }
+
+        uint64 GetData64(uint32 data)
         {
-            switch (uiData)
+            switch(data)
             {
                 case DATA_ANNOUNCER: return uiAnnouncerGUID;
+                case DATA_TIRION: return uiTirionGUID;
+                case DATA_THRALL: return uiThrallGUID;
+                case DATA_GARROSH: return uiGarroshGUID;
+                case DATA_VARIAN: return uiVarianGUID;
+                case DATA_JAINA: return uiJainaGUID;
                 case DATA_MAIN_GATE: return uiMainGateGUID;
-
-                case DATA_GRAND_CHAMPION_1: return uiGrandChampion1GUID;
-                case DATA_GRAND_CHAMPION_2: return uiGrandChampion2GUID;
-                case DATA_GRAND_CHAMPION_3: return uiGrandChampion3GUID;
+                case DATA_PORTCULLIS: return uiPortcullisGUID;
+                case DATA_CHEST: return uiChampionLootGUID;
+                case DATA_BLACK_KNIGHT: return uiBlackKnightGUID;
+                case DATA_BLACK_KNIGHT_GRYPHON: return uiBlackKnightGryphonGUID;
             }
 
             return 0;
         }
 
-        void SetData64(uint32 uiType, uint64 uiData)
+        bool CheckAchievementCriteriaMeet(uint32 criteria_id, Player const* /*source*/, Unit const* /*target*/, uint32 /*miscvalue1*/)
         {
-            switch (uiType)
+            switch(criteria_id)
             {
-                case DATA_GRAND_CHAMPION_1:
-                    uiGrandChampion1GUID = uiData;
-                    break;
-                case DATA_GRAND_CHAMPION_2:
-                    uiGrandChampion2GUID = uiData;
-                    break;
-                case DATA_GRAND_CHAMPION_3:
-                    uiGrandChampion3GUID = uiData;
-                    break;
+                case CRITERIA_CHAMPION_JACOB:
+                case CRITERIA_CHAMPION_LANA:
+                case CRITERIA_CHAMPION_COLOSOS:
+                case CRITERIA_CHAMPION_AMBROSE:
+                case CRITERIA_CHAMPION_JAELYNE:
+                case CRITERIA_CHAMPION_MOKRA:
+                case CRITERIA_CHAMPION_VISCERI:
+                case CRITERIA_CHAMPION_RUNOK:
+                case CRITERIA_CHAMPION_ERESSEA:
+                case CRITERIA_CHAMPION_ZULTORE:
+                case CRITERIA_CHAMPION_JACOB_H:
+                case CRITERIA_CHAMPION_LANA_H:
+                case CRITERIA_CHAMPION_COLOSOS_H:
+                case CRITERIA_CHAMPION_AMBROSE_H:
+                case CRITERIA_CHAMPION_JAELYNE_H:
+                case CRITERIA_CHAMPION_MOKRA_H:
+                case CRITERIA_CHAMPION_VISCERI_H:
+                case CRITERIA_CHAMPION_RUNOK_H:
+                case CRITERIA_CHAMPION_ERESSEA_H:
+                case CRITERIA_CHAMPION_ZULTORE_H:
+                    for(uint8 i = 0; i<3; i++)
+                        if(grandChampionEntry[i] == GetRelatedCreatureEntry(criteria_id))
+                            return true;
+                    return false;
+                case CRITERIA_MEMORY_HOGGER:
+                case CRITERIA_MEMORY_VANCLEEF:
+                case CRITERIA_MEMORY_MUTANUS:
+                case CRITERIA_MEMORY_HEROD:
+                case CRITERIA_MEMORY_LUCIFROM:
+                case CRITERIA_MEMORY_THUNDERAAN:
+                case CRITERIA_MEMORY_CHROMAGGUS:
+                case CRITERIA_MEMORY_HAKKAR:
+                case CRITERIA_MEMORY_VEKNILASH:
+                case CRITERIA_MEMORY_KALITHRESH:
+                case CRITERIA_MEMORY_MALCHEZAAR:
+                case CRITERIA_MEMORY_GRUUL:
+                case CRITERIA_MEMORY_VASHJ:
+                case CRITERIA_MEMORY_ARCHIMONDE:
+                case CRITERIA_MEMORY_ILLIDAN:
+                case CRITERIA_MEMORY_DELRISSA:
+                case CRITERIA_MEMORY_MURU:
+                case CRITERIA_MEMORY_INGVAR:
+                case CRITERIA_MEMORY_CYANIGOSA:
+                case CRITERIA_MEMORY_ECK:
+                case CRITERIA_MEMORY_ONYXIA:
+                case CRITERIA_MEMORY_HEIGAN:
+                case CRITERIA_MEMORY_IGNIS:
+                case CRITERIA_MEMORY_VEZAX:
+                case CRITERIA_MEMORY_ALGALON:
+                    return (memoryEntry == GetRelatedCreatureEntry(criteria_id));
+                case CRITERIA_I_VE_HAD_WORSE:
+                    return achievementHadWorse;
             }
-        }
 
+            return false;
+        }
+        uint32 GetRelatedCreatureEntry(uint32 criteria_id)
+        {
+            switch(criteria_id)
+            {
+                case CRITERIA_CHAMPION_JACOB:
+                case CRITERIA_CHAMPION_JACOB_H:
+                    return NPC_JACOB;
+                case CRITERIA_CHAMPION_LANA:
+                case CRITERIA_CHAMPION_LANA_H:
+                    return NPC_LANA;
+                case CRITERIA_CHAMPION_COLOSOS:
+                case CRITERIA_CHAMPION_COLOSOS_H:
+                    return NPC_COLOSOS;
+                case CRITERIA_CHAMPION_AMBROSE:
+                case CRITERIA_CHAMPION_AMBROSE_H:
+                    return NPC_AMBROSE;
+                case CRITERIA_CHAMPION_JAELYNE:
+                case CRITERIA_CHAMPION_JAELYNE_H:
+                    return NPC_JAELYNE;
+                case CRITERIA_CHAMPION_MOKRA:
+                case CRITERIA_CHAMPION_MOKRA_H:
+                    return NPC_MOKRA;
+                case CRITERIA_CHAMPION_VISCERI:
+                case CRITERIA_CHAMPION_VISCERI_H:
+                    return NPC_VISCERI;
+                case CRITERIA_CHAMPION_RUNOK:
+                case CRITERIA_CHAMPION_RUNOK_H:
+                    return NPC_RUNOK;
+                case CRITERIA_CHAMPION_ERESSEA:
+                case CRITERIA_CHAMPION_ERESSEA_H:
+                    return NPC_ERESSEA;
+                case CRITERIA_CHAMPION_ZULTORE:
+                case CRITERIA_CHAMPION_ZULTORE_H:
+                    return NPC_ZULTORE;
+
+                case CRITERIA_MEMORY_HOGGER:     return NPC_MEMORY_HOGGER;
+                case CRITERIA_MEMORY_VANCLEEF:   return NPC_MEMORY_VANCLEEF;
+                case CRITERIA_MEMORY_MUTANUS:    return NPC_MEMORY_MUTANUS;
+                case CRITERIA_MEMORY_HEROD:      return NPC_MEMORY_HEROD;
+                case CRITERIA_MEMORY_LUCIFROM:   return NPC_MEMORY_LUCIFROM;
+                case CRITERIA_MEMORY_THUNDERAAN: return NPC_MEMORY_THUNDERAAN;
+                case CRITERIA_MEMORY_CHROMAGGUS: return NPC_MEMORY_CHROMAGGUS;
+                case CRITERIA_MEMORY_HAKKAR:     return NPC_MEMORY_HAKKAR;
+                case CRITERIA_MEMORY_VEKNILASH:  return NPC_MEMORY_VEKNILASH;
+                case CRITERIA_MEMORY_KALITHRESH: return NPC_MEMORY_KALITHRESH;
+                case CRITERIA_MEMORY_MALCHEZAAR: return NPC_MEMORY_MALCHEZAAR;
+                case CRITERIA_MEMORY_GRUUL:      return NPC_MEMORY_GRUUL;
+                case CRITERIA_MEMORY_VASHJ:      return NPC_MEMORY_VASHJ;
+                case CRITERIA_MEMORY_ARCHIMONDE: return NPC_MEMORY_ARCHIMONDE;
+                case CRITERIA_MEMORY_ILLIDAN:    return NPC_MEMORY_ILLIDAN;
+                case CRITERIA_MEMORY_DELRISSA:   return NPC_MEMORY_DELRISSA;
+                case CRITERIA_MEMORY_MURU:       return NPC_MEMORY_MURU;
+                case CRITERIA_MEMORY_INGVAR:     return NPC_MEMORY_INGVAR;
+                case CRITERIA_MEMORY_CYANIGOSA:  return NPC_MEMORY_CYANIGOSA;
+                case CRITERIA_MEMORY_ECK:        return NPC_MEMORY_ECK;
+                case CRITERIA_MEMORY_ONYXIA:     return NPC_MEMORY_ONYXIA;
+                case CRITERIA_MEMORY_HEIGAN:     return NPC_MEMORY_HEIGAN;
+                case CRITERIA_MEMORY_IGNIS:      return NPC_MEMORY_IGNIS;
+                case CRITERIA_MEMORY_VEZAX:      return NPC_MEMORY_VEZAX;
+                case CRITERIA_MEMORY_ALGALON:    return NPC_MEMORY_ALGALON;
+            }
+            return 0;
+        }
         std::string GetSaveData()
         {
             OUT_SAVE_INST_DATA;
@@ -288,14 +443,10 @@ public:
             saveStream << "T C " << m_auiEncounter[0]
                 << ' ' << m_auiEncounter[1]
                 << ' ' << m_auiEncounter[2]
-                << ' ' << m_auiEncounter[3]
-                << ' ' << uiGrandChampionsDeaths
-                << ' ' << uiMovementDone;
-
-            str_data = saveStream.str();
+                << ' ' << m_auiEncounter[3];
 
             OUT_SAVE_INST_DATA_COMPLETE;
-            return str_data;
+            return  saveStream.str();
         }
 
         void Load(const char* in)
@@ -309,10 +460,10 @@ public:
             OUT_LOAD_INST_DATA(in);
 
             char dataHead1, dataHead2;
-            uint16 data0, data1, data2, data3, data4, data5;
+            uint16 data0, data1, data2, data3;
 
             std::istringstream loadStream(in);
-            loadStream >> dataHead1 >> dataHead2 >> data0 >> data1 >> data2 >> data3 >> data4 >> data5;
+            loadStream >> dataHead1 >> dataHead2 >> data0 >> data1 >> data2 >> data3;
 
             if (dataHead1 == 'T' && dataHead2 == 'C')
             {
@@ -325,8 +476,11 @@ public:
                     if (m_auiEncounter[i] == IN_PROGRESS)
                         m_auiEncounter[i] = NOT_STARTED;
 
-                uiGrandChampionsDeaths = data4;
-                uiMovementDone = data5;
+                if (m_auiEncounter[1] != DONE && (m_auiEncounter[1] == DONE || m_auiEncounter[2] == DONE))
+                {
+                    // TODO: Respawn announcer OR Spawn Black Knight on the arena
+                }
+
             } else OUT_LOAD_INST_DATA_FAIL;
 
             OUT_LOAD_INST_DATA_COMPLETE;
diff --git a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/trial_of_the_champion.cpp b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/trial_of_the_champion.cpp
index c17ea74..c3c864a 100644
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/trial_of_the_champion.cpp
+++ b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/trial_of_the_champion.cpp
@@ -17,7 +17,7 @@
 
 /* ScriptData
 SDName: Trial Of the Champion
-SD%Complete:
+SD%Complete: 90%
 SDComment:
 SDCategory: trial_of_the_champion
 EndScriptData */
@@ -30,8 +30,9 @@ EndContentData */
 #include "trial_of_the_champion.h"
 #include "Vehicle.h"
 
-#define GOSSIP_START_EVENT1     "I'm ready to start challenge."
-#define GOSSIP_START_EVENT2     "I'm ready for the next challenge."
+#define GOSSIP_START_EVENT1     "Estamos listos para comenzar el desafio."  // "I'm ready to start challenge."
+#define GOSSIP_START_EVENT2     "Estamos preparados para el siguiete reto." // "I'm ready for the next challenge."
+#define GOSSIP_START_EVENT3     "Afrontaremos el ultimo reto." // "Let's face our last challenge."
 
 #define ORIENTATION             4.714f
 
@@ -39,8 +40,88 @@ EndContentData */
 ## npc_announcer_toc5
 ######*/
 
-const Position SpawnPosition = {746.261f, 657.401f, 411.681f, 4.65f};
+const Position SpawnPosition = {746.565f, 665.056f, 411.756f, 4.77922f};
+const Position GrandChampionSpawnPosition = {746.768f, 655.148f, 411.614f, 4.6842f};
+const Position OutStadiumPosition = {747.03f, 687.483f, 412.373f, 1.53475f};
+const Position AnnouncerPosition = {731.585f, 658.719f, 412.393f, 4.61586f};
+const Position BlackKnightSpawnPosition = {796.404f, 643.282f, 466.518f, 2.33348f};
+const Position FactionChampionPos[2][3] =
+{
+    {
+        // Horde
+        {724.854f, 640.344f, 411.829f, 5.60704f},
+        {714.172f, 618.206f, 411.604f, 0.0f},
+        {724.300f, 595.990f, 411.568f, 0.819248f},
+    },
+    {
+        // Alliance
+        {767.643f, 639.450f, 411.757f, 3.3663f},
+        {779.169f, 618.351f, 411.607f, 3.06471f},
+        {769.012f, 596.386f, 411.569f, 2.92883f},
+    },
+};
+const Position ArgentSoldierPosition[3] =
+{
+    {746.875f, 650.358f, 411.569f, 4.77922f},
+    {717.771f, 647.165f, 411.923f, 5.54734f},
+    {775.734f, 644.413f, 411.919f, 3.79826f}
+};
+
+enum Says
+{
+
+    // Grand Champions
+    SAY_TIRION_INTRO_CHAMPS_1  = 0,
+
+    // Horde
+    SAY_THRALL_INTRO_CHAMPS_H  = 0,
+    SAY_GARROSH_INTRO_CHAMPS_H = 0,
+    SAY_VARIAN_INTRO_CHAMPS_H  = 0,
+    SAY_JAINA_INTRO_CHAMPS_H   = 0,
+    // Alliance
+    SAY_VARIAN_INTRO_CHAMPS_A  = 1,
+    SAY_JAINA_INTRO_CHAMPS_A   = 1,
+    SAY_GARROSH_INTRO_CHAMPS_A = 1,
+    SAY_THRALL_INTRO_CHAMPS_A  = 1,
+
+    SAY_TIRION_INTRO_CHAMPS_2  = 1,
+
+    SAY_ANNOUNCER_NPC_MAGE     = 1,
+    SAY_ANNOUNCER_NPC_SHAMAN   = 2,
+    SAY_ANNOUNCER_NPC_HUNTER   = 3,
+    SAY_ANNOUNCER_NPC_WARRIOR  = 4,
+    SAY_ANNOUNCER_NPC_ROUGE    = 5,
+    SAY_ANNOUNCER_INTRO_PLAYER = 0,
+    SAY_ANNOUNCER_PLAYER       = -1999920,
+    EMOTE_FACTION_CHEER        = -1999900,
+
+    // Argent Challenge
+    SAY_TIRION_INTRO_ARGENT_1  = 2,
+    SAY_ANNOUNCER_EADRIC       = 11,
+    SAY_ANNOUNCER_PALETRESS    = 12,
+    SAY_EADRIC_INTRO           = 10,
+    SAY_PALETRESS_INTRO_1      = 10,
+    SAY_PALETRESS_INTRO_2      = 11,
+    SAY_TIRION_INTRO_ARGENT_2  = 3,
+
+    // Black Knight
+    SAY_TIRION_INTRO_BK_1     = 4,
+    SAY_ANNOUNCER_BK          = 13,
+    SAY_BK_INTRO_1            = 10,
+    SAY_TIRION_INTRO_BK_2     = 5,
+    SAY_BK_INTRO_2            = 11,
+    SAY_BK_INTRO_3            = 12,
+    SAY_VARIAN_INTRO_BK       = 10,
+    SAY_GARROSH_INTRO_BK      = 10,
+};
 
+enum GossipTexts
+{
+    GOSSIP_TEXT_NOT_MOUNTED_HORDE          = 15043,
+    GOSSIP_TEXT_NOT_MOUNTED_ALLIANCE       = 14757,
+    GOSSIP_TEXT_FACTION_CHAMPIONS_DEFEATED = 14737,
+    GOSSIP_TEXT_ARGENT_CHAMPIONS_DEFEATED  = 14738,
+};
 class npc_announcer_toc5 : public CreatureScript
 {
 public:
@@ -50,411 +131,1262 @@ public:
     {
         npc_announcer_toc5AI(Creature* creature) : ScriptedAI(creature)
         {
-            instance = creature->GetInstanceScript();
-
-            uiSummonTimes = 0;
-            uiPosition = 0;
-            uiLesserChampions = 0;
-
-            uiFirstBoss = 0;
-            uiSecondBoss = 0;
-            uiThirdBoss = 0;
-
-            uiArgentChampion = 0;
-
-            uiPhase = 0;
-            uiTimer = 0;
-
-            uiVehicle1GUID = 0;
-            uiVehicle2GUID = 0;
-            uiVehicle3GUID = 0;
-
-            Champion1List.clear();
-            Champion2List.clear();
-            Champion3List.clear();
-
-            me->SetReactState(REACT_PASSIVE);
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-            me->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
-
-            SetGrandChampionsForEncounter();
-            SetArgentChampion();
+            instance = me->GetInstanceScript();
         }
 
         InstanceScript* instance;
+        EventMap events;
 
-        uint8 uiSummonTimes;
-        uint8 uiPosition;
-        uint8 uiLesserChampions;
+        uint32 eventIds[EVENTS_MAX];
 
-        uint32 uiArgentChampion;
+        uint32 bossEntry[3];
+        uint64 bossGUID[3];
+        uint64 addsGUID[3][3];
+        uint64 stalkerGUID;
+        std::set<int32> announceID;
+        std::set<uint64> playersGUID;
 
-        uint32 uiFirstBoss;
-        uint32 uiSecondBoss;
-        uint32 uiThirdBoss;
+        bool addsAttacking;
+        uint8 defeatedCount;
 
-        uint32 uiPhase;
-        uint32 uiTimer;
+        const Position* FactionChampionPosition()
+        {
+            if (instance->GetData(DATA_TEAM) == HORDE)
+                return FactionChampionPos[1];
+            else
+                return FactionChampionPos[0];
+        }
 
-        uint64 uiVehicle1GUID;
-        uint64 uiVehicle2GUID;
-        uint64 uiVehicle3GUID;
+        void Reset()
+        {
+            events.Reset();
+            for (uint8 i=0; i<EVENTS_MAX; i++)
+                eventIds[i] = 0;
 
-        uint64 uiGrandChampionBoss1;
+            for (uint8 i=0; i<3; i++)
+            {
+                bossEntry[i] = 0;
+                bossGUID[i] = 0;
+                for (uint8 j=0; j<3; j++)
+                    addsGUID[i][j] = 0;
+            }
 
-        std::list<uint64> Champion1List;
-        std::list<uint64> Champion2List;
-        std::list<uint64> Champion3List;
+            announceID.clear();
+            playersGUID.clear();
+            stalkerGUID = 0;
+            defeatedCount = 0;
+            addsAttacking = false;
+        }
 
-        void NextStep(uint32 uiTimerStep, bool bNextStep = true, uint8 uiPhaseStep = 0)
+        void JustSummoned(Creature* summon)
         {
-            uiTimer = uiTimerStep;
-            if (bNextStep)
-                ++uiPhase;
-            else
-                uiPhase = uiPhaseStep;
+            summon->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            summon->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+            summon->SetReactState(REACT_PASSIVE);
         }
 
-        void SetData(uint32 uiType, uint32 /*uiData*/)
+        void SetData(uint32 type, uint32 data)
         {
-            switch (uiType)
+            eventIds[type] = data;
+
+            if (data == IN_PROGRESS)
             {
-                case DATA_START:
-                    DoSummonGrandChampion(uiFirstBoss);
-                    NextStep(10000, false, 1);
-                    break;
-                case DATA_IN_POSITION: //movement done.
-                    me->GetMotionMaster()->MovePoint(1, 735.81f, 661.92f, 412.39f);
-                    if (GameObject* pGO = GameObject::GetGameObject(*me, instance->GetData64(DATA_MAIN_GATE)))
-                        instance->HandleGameObject(pGO->GetGUID(), false);
-                    NextStep(10000, false, 3);
-                    break;
-                case DATA_LESSER_CHAMPIONS_DEFEATED:
+                events.ScheduleEvent(1, 0);
+                if (type == EVENT_INTRO)
                 {
-                    ++uiLesserChampions;
-                    std::list<uint64> TempList;
-                    if (uiLesserChampions == 3 || uiLesserChampions == 6)
+                    Map::PlayerList const &PlList = me->GetMap()->GetPlayers();
+
+                    if (!PlList.isEmpty())
                     {
-                        switch (uiLesserChampions)
+                        for (Map::PlayerList::const_iterator i = PlList.begin(); i != PlList.end(); ++i)
                         {
-                            case 3:
-                                TempList = Champion2List;
-                                break;
-                            case 6:
-                                TempList = Champion3List;
-                                break;
-                        }
+                            if (Player* player = i->getSource())
+                            {
+                                if (player->isGameMaster())
+                                    continue;
 
-                        for (std::list<uint64>::const_iterator itr = TempList.begin(); itr != TempList.end(); ++itr)
-                            if (Creature* summon = Unit::GetCreature(*me, *itr))
-                                AggroAllPlayers(summon);
-                    }else if (uiLesserChampions == 9)
-                        StartGrandChampionsAttack();
+                                playersGUID.insert(player->GetGUID());
+                            }
+                        }
+                        for (uint8 i = 0; i<playersGUID.size(); i++)
+                            announceID.insert(SAY_ANNOUNCER_PLAYER-i);
+                    }
 
-                    break;
+                    SetGrandChampionsForEncounter();
                 }
             }
         }
 
-        void StartGrandChampionsAttack()
+        void SetGrandChampionsForEncounter()
         {
-            Creature* pGrandChampion1 = Unit::GetCreature(*me, uiVehicle1GUID);
-            Creature* pGrandChampion2 = Unit::GetCreature(*me, uiVehicle2GUID);
-            Creature* pGrandChampion3 = Unit::GetCreature(*me, uiVehicle3GUID);
+            if (instance->GetData(DATA_TEAM) == HORDE)
+                bossEntry[0] = RAND(NPC_JACOB, NPC_LANA);
+            else
+                bossEntry[0] = RAND(NPC_MOKRA, NPC_VISCERI);
 
-            if (pGrandChampion1 && pGrandChampion2 && pGrandChampion3)
+            while (bossEntry[1] == bossEntry[0] || bossEntry[2] == bossEntry[0] || bossEntry[2] == bossEntry[1])
             {
-                AggroAllPlayers(pGrandChampion1);
-                AggroAllPlayers(pGrandChampion2);
-                AggroAllPlayers(pGrandChampion3);
+                if (instance->GetData(DATA_TEAM) == HORDE)
+                {
+                    bossEntry[1] = RAND(NPC_JACOB, NPC_AMBROSE, NPC_COLOSOS, NPC_JAELYNE, NPC_LANA);
+                    bossEntry[2] = RAND(NPC_JACOB, NPC_AMBROSE, NPC_COLOSOS, NPC_JAELYNE, NPC_LANA);
+                }else
+                {
+                    bossEntry[1] = RAND(NPC_MOKRA, NPC_ERESSEA, NPC_RUNOK, NPC_ZULTORE, NPC_VISCERI);
+                    bossEntry[2] = RAND(NPC_MOKRA, NPC_ERESSEA, NPC_RUNOK, NPC_ZULTORE, NPC_VISCERI);
+                }
             }
         }
 
-        void MovementInform(uint32 uiType, uint32 uiPointId)
+        uint32 GetData(uint32 type)
         {
-            if (uiType != POINT_MOTION_TYPE)
-                return;
+            return eventIds[type];
+        }
 
-            if (uiPointId == 1)
+        uint32 GetAddId(uint32 bossId)
+        {
+            switch(bossId)
             {
-                me->SetOrientation(ORIENTATION);
-                me->SendMovementFlagUpdate();
+                // Alliance
+                case NPC_JACOB:   return NPC_STORMWIND_CHAMPION;
+                case NPC_AMBROSE: return NPC_GNOMEREGAN_CHAMPION;
+                case NPC_COLOSOS: return NPC_EXODAR_CHAMPION;
+                case NPC_JAELYNE: return NPC_DARNASSUS_CHAMPION;
+                case NPC_LANA:    return NPC_IRONFORGE_CHAMPION;
+                // Horde
+                case NPC_MOKRA:   return NPC_ORGRIMMAR_CHAMPION;
+                case NPC_ERESSEA: return NPC_SILVERMOON_CHAMPION;
+                case NPC_RUNOK:   return NPC_THUNDER_BLUFF_CHAMPION;
+                case NPC_ZULTORE: return NPC_SENJIN_CHAMPION;
+                case NPC_VISCERI: return NPC_UNDERCITY_CHAMPION;
             }
+            return 0;
         }
 
-        void DoSummonGrandChampion(uint32 uiBoss)
+        void AnnounceChampion(Unit* champion)
         {
-            ++uiSummonTimes;
-            uint32 VEHICLE_TO_SUMMON1 = 0;
-            uint32 VEHICLE_TO_SUMMON2 = 0;
-            switch (uiBoss)
+            if (champion->GetTypeId() ==  TYPEID_PLAYER)
             {
-                case 0:
-                    VEHICLE_TO_SUMMON1 = VEHICLE_MOKRA_SKILLCRUSHER_MOUNT;
-                    VEHICLE_TO_SUMMON2 = VEHICLE_ORGRIMMAR_WOLF;
-                    break;
-                case 1:
-                    VEHICLE_TO_SUMMON1 = VEHICLE_ERESSEA_DAWNSINGER_MOUNT;
-                    VEHICLE_TO_SUMMON2 = VEHICLE_SILVERMOON_HAWKSTRIDER;
-                    break;
-                case 2:
-                    VEHICLE_TO_SUMMON1 = VEHICLE_RUNOK_WILDMANE_MOUNT;
-                    VEHICLE_TO_SUMMON2 = VEHICLE_THUNDER_BLUFF_KODO;
-                    break;
-                case 3:
-                    VEHICLE_TO_SUMMON1 = VEHICLE_ZUL_TORE_MOUNT;
-                    VEHICLE_TO_SUMMON2 = VEHICLE_DARKSPEAR_RAPTOR;
-                    break;
-                case 4:
-                    VEHICLE_TO_SUMMON1 = VEHICLE_DEATHSTALKER_VESCERI_MOUNT;
-                    VEHICLE_TO_SUMMON2 = VEHICLE_FORSAKE_WARHORSE;
-                    break;
-                default:
-                    return;
+                if (!playersGUID.empty())
+                {
+                    if(Player* player = me->GetPlayer(*me, *playersGUID.begin()))
+                    {
+                        if (!announceID.empty())
+                        {
+                            int32 announce = SelectRandomContainerElement(announceID);
+                            DoScriptText(announce, me, player);
+                            announceID.erase(announce);
+                        }
+                        playersGUID.erase(*playersGUID.begin());
+                        // Public emote
+                        DoScriptText(EMOTE_FACTION_CHEER-player->getRace(), player);
+                    }
+                }
+            }
+            else
+            {
+                switch (champion->GetEntry())
+                {
+                    case NPC_MOKRA: // Warrior
+                        Talk(SAY_ANNOUNCER_NPC_WARRIOR);
+                        DoScriptText(EMOTE_FACTION_CHEER-RACE_ORC, champion);
+                        break;
+                    case NPC_JACOB:
+                        Talk(SAY_ANNOUNCER_NPC_WARRIOR);
+                        DoScriptText(EMOTE_FACTION_CHEER-RACE_HUMAN, champion);
+                        break;
+                    case NPC_ERESSEA: // Mage
+                        Talk(SAY_ANNOUNCER_NPC_MAGE);
+                        DoScriptText(EMOTE_FACTION_CHEER-RACE_BLOODELF, champion);
+                        break;
+                    case NPC_AMBROSE:
+                        Talk(SAY_ANNOUNCER_NPC_MAGE);
+                        DoScriptText(EMOTE_FACTION_CHEER-RACE_GNOME, champion);
+                        break;
+                    case NPC_RUNOK: // Saman
+                        Talk(SAY_ANNOUNCER_NPC_SHAMAN);
+                        DoScriptText(EMOTE_FACTION_CHEER-RACE_TAUREN, champion);
+                        break;
+                    case NPC_COLOSOS:
+                        Talk(SAY_ANNOUNCER_NPC_SHAMAN);
+                        DoScriptText(EMOTE_FACTION_CHEER-RACE_DRAENEI, champion);
+                        break;
+                    case NPC_JAELYNE: // Hunter
+                        Talk(SAY_ANNOUNCER_NPC_HUNTER);
+                        DoScriptText(EMOTE_FACTION_CHEER-RACE_NIGHTELF, champion);
+                        break;
+                    case NPC_ZULTORE:
+                        Talk(SAY_ANNOUNCER_NPC_HUNTER);
+                        DoScriptText(EMOTE_FACTION_CHEER-RACE_TROLL, champion);
+                        break;
+                    case NPC_VISCERI: // Rouge
+                        Talk(SAY_ANNOUNCER_NPC_ROUGE);
+                        DoScriptText(EMOTE_FACTION_CHEER-RACE_UNDEAD_PLAYER, champion);
+                        break;
+                    case NPC_LANA:
+                        Talk(SAY_ANNOUNCER_NPC_ROUGE);
+                        DoScriptText(EMOTE_FACTION_CHEER-RACE_DWARF, champion);
+                        break;
+                    case NPC_EADRIC:
+                        Talk(SAY_ANNOUNCER_EADRIC);
+                        DoScriptText(EMOTE_FACTION_CHEER, champion);
+                        break;
+                    case NPC_PALETRESS:
+                        Talk(SAY_ANNOUNCER_PALETRESS);
+                        DoScriptText(EMOTE_FACTION_CHEER, champion);
+                        break;
+                }
             }
+        }
 
-            if (Creature* pBoss = me->SummonCreature(VEHICLE_TO_SUMMON1, SpawnPosition))
+        void UpdateAI(const uint32 diff)
+        {
+            events.Update(diff);
+
+            if (GetData(EVENT_INTRO) == IN_PROGRESS)
             {
-                switch (uiSummonTimes)
+                switch(events.ExecuteEvent())
                 {
                     case 1:
-                    {
-                        uiVehicle1GUID = pBoss->GetGUID();
-                        uint64 uiGrandChampionBoss1 = 0;
-                        if (Vehicle* pVehicle = pBoss->GetVehicleKit())
-                            if (Unit* unit = pVehicle->GetPassenger(0))
-                                uiGrandChampionBoss1 = unit->GetGUID();
-                        if (instance)
+                        Talk(SAY_ANNOUNCER_INTRO_PLAYER);
+                        events.ScheduleEvent(2, 7000);
+                        break;
+                    case 2:
+                        if (!playersGUID.empty())
+                        {
+                            if (Player* player = me->GetMap()->GetPlayers().begin()->getSource())
+                                AnnounceChampion(player);
+                            events.ScheduleEvent(2, 8000);
+                        } else
+                            events.ScheduleEvent(3, 8000);
+
+                        break;
+                    case 3:
+                        if (Creature* tirion = me->GetCreature(*me, instance->GetData64(DATA_TIRION)))
+                            tirion->AI()->Talk(SAY_TIRION_INTRO_CHAMPS_1);
+
+                        events.ScheduleEvent(4, 8000);
+                        break;
+                    case 4:
+                        if (instance->GetData(DATA_TEAM) == HORDE)
+                        {
+                            if (Creature* thrall = me->GetCreature(*me, instance->GetData64(DATA_THRALL)))
+                                thrall->AI()->Talk(SAY_THRALL_INTRO_CHAMPS_H);
+                            events.ScheduleEvent(5, 5000);
+                        } else
                         {
-                            instance->SetData64(DATA_GRAND_CHAMPION_VEHICLE_1, uiVehicle1GUID);
-                            instance->SetData64(DATA_GRAND_CHAMPION_1, uiGrandChampionBoss1);
+                            if (Creature* varian = me->GetCreature(*me, instance->GetData64(DATA_VARIAN)))
+                                varian->AI()->Talk(SAY_VARIAN_INTRO_CHAMPS_A);
+                            events.ScheduleEvent(5, 8000);
                         }
-                        pBoss->AI()->SetData(1, 0);
                         break;
-                    }
-                    case 2:
-                    {
-                        uiVehicle2GUID = pBoss->GetGUID();
-                        uint64 uiGrandChampionBoss2 = 0;
-                        if (Vehicle* pVehicle = pBoss->GetVehicleKit())
-                            if (Unit* unit = pVehicle->GetPassenger(0))
-                                uiGrandChampionBoss2 = unit->GetGUID();
-                        if (instance)
+                    case 5:
+                        if (instance->GetData(DATA_TEAM) == HORDE)
                         {
-                            instance->SetData64(DATA_GRAND_CHAMPION_VEHICLE_2, uiVehicle2GUID);
-                            instance->SetData64(DATA_GRAND_CHAMPION_2, uiGrandChampionBoss2);
+                            if (Creature* garrosh = me->GetCreature(*me, instance->GetData64(DATA_GARROSH)))
+                                garrosh->AI()->Talk(SAY_GARROSH_INTRO_CHAMPS_H);
+                            events.ScheduleEvent(6, 8000);
+                        } else
+                        {
+                            if (Creature* jaina = me->GetCreature(*me, instance->GetData64(DATA_JAINA)))
+                                jaina->AI()->Talk(SAY_JAINA_INTRO_CHAMPS_A);
+                            events.ScheduleEvent(6, 5000);
                         }
-                        pBoss->AI()->SetData(2, 0);
                         break;
-                    }
-                    case 3:
-                    {
-                        uiVehicle3GUID = pBoss->GetGUID();
-                        uint64 uiGrandChampionBoss3 = 0;
-                        if (Vehicle* pVehicle = pBoss->GetVehicleKit())
-                            if (Unit* unit = pVehicle->GetPassenger(0))
-                                uiGrandChampionBoss3 = unit->GetGUID();
-                        if (instance)
+                    case 6:
+                        if (instance->GetData(DATA_TEAM) == HORDE)
+                        {
+                            if (Creature* varian = me->GetCreature(*me, instance->GetData64(DATA_VARIAN)))
+                                varian->AI()->Talk(SAY_VARIAN_INTRO_CHAMPS_H);
+                            events.ScheduleEvent(7, 8000);
+                        } else
                         {
-                            instance->SetData64(DATA_GRAND_CHAMPION_VEHICLE_3, uiVehicle3GUID);
-                            instance->SetData64(DATA_GRAND_CHAMPION_3, uiGrandChampionBoss3);
+                            if (Creature* garrosh = me->GetCreature(*me, instance->GetData64(DATA_GARROSH)))
+                                garrosh->AI()->Talk(SAY_GARROSH_INTRO_CHAMPS_A);
+                            events.ScheduleEvent(7, 8000);
                         }
-                        pBoss->AI()->SetData(3, 0);
                         break;
-                    }
-                    default:
-                        return;
-                }
+                    case 7:
+                        if (instance->GetData(DATA_TEAM) == HORDE)
+                        {
+                            if (Creature* jaina = me->GetCreature(*me, instance->GetData64(DATA_JAINA)))
+                                jaina->AI()->Talk(SAY_JAINA_INTRO_CHAMPS_H);
+                            events.ScheduleEvent(8, 5000);
+                        } else
+                        {
+                            if (Creature* thrall = me->GetCreature(*me, instance->GetData64(DATA_THRALL)))
+                                thrall->AI()->Talk(SAY_THRALL_INTRO_CHAMPS_A);
+                            events.ScheduleEvent(8, 5000);
+                        }
+                        break;
+                    case 8:
+                        if (Creature* tirion = me->GetCreature(*me, instance->GetData64(DATA_TIRION)))
+                            tirion->AI()->Talk(SAY_TIRION_INTRO_CHAMPS_2);
 
-                for (uint8 i = 0; i < 3; ++i)
-                {
-                    if (Creature* pAdd = me->SummonCreature(VEHICLE_TO_SUMMON2, SpawnPosition, TEMPSUMMON_CORPSE_DESPAWN))
-                    {
-                        switch (uiSummonTimes)
-                        {
-                            case 1:
-                                Champion1List.push_back(pAdd->GetGUID());
-                                break;
-                            case 2:
-                                Champion2List.push_back(pAdd->GetGUID());
-                                break;
-                            case 3:
-                                Champion3List.push_back(pAdd->GetGUID());
-                                break;
-                        }
-
-                        switch (i)
-                        {
-                            case 0:
-                                pAdd->GetMotionMaster()->MoveFollow(pBoss, 2.0f, M_PI);
-                                break;
-                            case 1:
-                                pAdd->GetMotionMaster()->MoveFollow(pBoss, 2.0f, M_PI / 2);
-                                break;
-                            case 2:
-                                pAdd->GetMotionMaster()->MoveFollow(pBoss, 2.0f, M_PI / 2 + M_PI);
-                                break;
+                        // Open door
+                        if (GameObject* pGO = GameObject::GetGameObject(*me, instance->GetData64(DATA_MAIN_GATE)))
+                            instance->HandleGameObject(pGO->GetGUID(), true);
+
+                        events.ScheduleEvent(9, 7000);
+                        break;
+                    case 9:
+                        // Summon invisible trigger for orientation prupouses only
+                        if (Creature* stalker = me->SummonCreature(20562, me->GetPositionX() , me->GetPositionY(), me->GetPositionZ()))
+                            stalkerGUID = stalker->GetGUID();
+
+                        // Summon 1st Boss and adds and make them follow him
+                        if (Creature* boss = me->SummonCreature(bossEntry[0], SpawnPosition))
+                        {
+                            bossGUID[0] = boss->GetGUID();
+                            boss->SetTarget(stalkerGUID);
+                            AnnounceChampion(boss->ToUnit());
+
+                            for (uint8 i = 0; i < 3; ++i)
+                            {
+                                if (Creature* add = me->SummonCreature(GetAddId(boss->GetEntry()), SpawnPosition, TEMPSUMMON_MANUAL_DESPAWN))
+                                {
+                                    add->SetTarget(stalkerGUID);
+                                    addsGUID[0][i] = add->GetGUID();
+                                    switch(i)
+                                    {
+                                        case 0: add->GetMotionMaster()->MoveFollow(boss, 2.0f, M_PI); break;
+                                        case 1: add->GetMotionMaster()->MoveFollow(boss, 2.0f, M_PI / 2); break;
+                                        case 2: add->GetMotionMaster()->MoveFollow(boss, 2.0f, M_PI / 2 + M_PI); break;
+                                    }
+                                }
+                            }
                         }
-                    }
+                        events.ScheduleEvent(10, 2000);
+                        break;
+                    case 10:
+                        // Move first boss to the new position
+                        if (Creature* boss1 = me->GetCreature(*me, bossGUID[0]))
+                            boss1->GetMotionMaster()->MovePoint(0, FactionChampionPosition()[0]);
+
+                        events.ScheduleEvent(11, 5000);
+                        break;
+                    case 11:
+                        // Refresh the adds position
+                        for (uint8 i=0; i<1; i++)
+                        {
+                            if (Creature* boss = me->GetCreature(*me, bossGUID[i]))
+                            {
+                                boss->SetFacingToObject(me);
+                                for (uint8 j = 0; j<3; j++)
+                                {
+                                    if (Creature* add = me->GetCreature(*me, addsGUID[i][j]))
+                                    {
+                                        switch(j)
+                                        {
+                                            case 0: add->GetMotionMaster()->MoveFollow(boss, 2.0f, M_PI); break;
+                                            case 1: add->GetMotionMaster()->MoveFollow(boss, 2.0f, M_PI / 2); break;
+                                            case 2: add->GetMotionMaster()->MoveFollow(boss, 2.0f, M_PI / 2 + M_PI); break;
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                        events.ScheduleEvent(12, 3000);
+                        break;
+                    case 12:
+                        // Summon 2nd Boss and adds and make them follow him
+                        if (Creature* boss = me->SummonCreature(bossEntry[1], SpawnPosition))
+                        {
+                            bossGUID[1] = boss->GetGUID();
+                            boss->SetTarget(stalkerGUID);
+                            AnnounceChampion(boss->ToUnit());
+
+                            for (uint8 i = 0; i < 3; ++i)
+                            {
+                                if (Creature* add = me->SummonCreature(GetAddId(boss->GetEntry()), SpawnPosition, TEMPSUMMON_MANUAL_DESPAWN))
+                                {
+                                    add->SetTarget(stalkerGUID);
+                                    addsGUID[1][i] = add->GetGUID();
+                                    switch(i)
+                                    {
+                                        case 0: add->GetMotionMaster()->MoveFollow(boss, 2.0f, M_PI); break;
+                                        case 1: add->GetMotionMaster()->MoveFollow(boss, 2.0f, M_PI / 2); break;
+                                        case 2: add->GetMotionMaster()->MoveFollow(boss, 2.0f, M_PI / 2 + M_PI); break;
+                                    }
+                                }
+                            }
+                        }
+                        events.ScheduleEvent(13, 5000);
+                        break;
+                    case 13:
+                        // Move first boss to the new position
+                        if (Creature* boss1 = me->GetCreature(*me, bossGUID[0]))
+                            boss1->GetMotionMaster()->MovePoint(0, FactionChampionPosition()[1]);
+
+                        // Move second boss to the new position
+                        if (Creature* boss2 = me->GetCreature(*me, bossGUID[1]))
+                            boss2->GetMotionMaster()->MovePoint(0, FactionChampionPosition()[0]);
+
+                        events.ScheduleEvent(14, 5000);
+                        break;
+                    case 14:
+                        // Refresh the adds position
+                        for (uint8 i=0; i<2; i++)
+                        {
+                            if (Creature* boss = me->GetCreature(*me, bossGUID[i]))
+                            {
+                                boss->SetFacingToObject(me);
+                                for (uint8 j = 0; j<3; j++)
+                                {
+                                    if (Creature* add = me->GetCreature(*me, addsGUID[i][j]))
+                                    {
+                                        switch(j)
+                                        {
+                                            case 0: add->GetMotionMaster()->MoveFollow(boss, 2.0f, M_PI); break;
+                                            case 1: add->GetMotionMaster()->MoveFollow(boss, 2.0f, M_PI / 2); break;
+                                            case 2: add->GetMotionMaster()->MoveFollow(boss, 2.0f, M_PI / 2 + M_PI); break;
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                        events.ScheduleEvent(15, 4000);
+                        break;
+                    case 15:
+                        // Summon 3rd Boss and adds and make them follow him
+                        if (Creature* boss = me->SummonCreature(bossEntry[2], SpawnPosition))
+                        {
+                            bossGUID[2] = boss->GetGUID();
+                            boss->SetTarget(stalkerGUID);
+                            AnnounceChampion(boss->ToUnit());
+
+                            for (uint8 i = 0; i < 3; ++i)
+                            {
+                                if (Creature* add = me->SummonCreature(GetAddId(boss->GetEntry()), SpawnPosition, TEMPSUMMON_MANUAL_DESPAWN))
+                                {
+                                    add->SetTarget(stalkerGUID);
+                                    addsGUID[2][i] = add->GetGUID();
+                                    switch(i)
+                                    {
+                                        case 0: add->GetMotionMaster()->MoveFollow(boss, 2.0f, M_PI); break;
+                                        case 1: add->GetMotionMaster()->MoveFollow(boss, 2.0f, M_PI / 2); break;
+                                        case 2: add->GetMotionMaster()->MoveFollow(boss, 2.0f, M_PI / 2 + M_PI); break;
+                                    }
+                                }
+                            }
+                        }
+                        events.ScheduleEvent(16, 4000);
+                        break;
+                    case 16:
+                        // Move first boss to the new position
+                        if (Creature* boss1 = me->GetCreature(*me, bossGUID[0]))
+                            boss1->GetMotionMaster()->MovePoint(0, FactionChampionPosition()[2]);
 
+                        // Move second boss to the new position
+                        if (Creature* boss2 = me->GetCreature(*me, bossGUID[1]))
+                            boss2->GetMotionMaster()->MovePoint(0, FactionChampionPosition()[1]);
+
+                        // Move third boss to the new position
+                        if (Creature* boss2 = me->GetCreature(*me, bossGUID[2]))
+                            boss2->GetMotionMaster()->MovePoint(0, FactionChampionPosition()[0]);
+
+                        events.ScheduleEvent(17, 5000);
+                        break;
+                    case 17:
+                        // Refresh the adds position
+                        for (uint8 i=0; i<3; i++)
+                        {
+                            if (Creature* boss = me->GetCreature(*me, bossGUID[i]))
+                            {
+                                boss->SetFacingToObject(me);
+                                for (uint8 j = 0; j<3; j++)
+                                {
+                                    if (Creature* add = me->GetCreature(*me, addsGUID[i][j]))
+                                    {
+                                        switch(j)
+                                        {
+                                            case 0: add->GetMotionMaster()->MoveFollow(boss, 2.0f, M_PI); break;
+                                            case 1: add->GetMotionMaster()->MoveFollow(boss, 2.0f, M_PI / 2); break;
+                                            case 2: add->GetMotionMaster()->MoveFollow(boss, 2.0f, M_PI / 2 + M_PI); break;
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                        events.ScheduleEvent(18, 4000);
+                        break;
+                    case 18:
+                        // Set home positions, in case of wipe, this avoids summons to go to the SpawnPos
+                        for (uint8 i=0; i<3; i++)
+                            if (Creature* boss = me->GetCreature(*me, bossGUID[i]))
+                            {
+                                boss->SetTarget(0);
+                                boss->CastSpell(boss, SPELL_MOUNT_LANCE_STAND, true);
+                                boss->SetHomePosition(boss->GetPositionX(), boss->GetPositionY(), boss->GetPositionZ(), boss->GetOrientation());
+                            }
+
+                        for (uint8 i=0; i<3; i++)
+                            for (uint8 j=0; j<3; j++)
+                                if (Creature* add = me->GetCreature(*me, addsGUID[i][j]))
+                                {
+                                    add->SetTarget(0);
+                                    add->SetFacingToObject(me);
+                                    add->CastSpell(add, SPELL_MOUNT_LANCE_STAND, true);
+                                    add->SetHomePosition(add->GetPositionX(), add->GetPositionY(), add->GetPositionZ(), add->GetOrientation());
+                                }
+
+                        // Move to the door position
+                        me->SetUnitMovementFlags(MOVEMENTFLAG_WALKING);
+                        me->GetMotionMaster()->MovePoint(0, AnnouncerPosition);
+                        me->SetTarget(stalkerGUID);
+                        events.ScheduleEvent(19, 19000);
+                        break;
+                    case 19:
+                        //Close Door
+                        if (GameObject* pGO = GameObject::GetGameObject(*me, instance->GetData64(DATA_MAIN_GATE)))
+                            instance->HandleGameObject(pGO->GetGUID(), false);
+
+                        events.Reset();
+                        SetData(EVENT_INTRO, DONE);
+                        SetData(EVENT_WAVES, IN_PROGRESS);
+                        break;
                 }
             }
-        }
 
-        void DoStartArgentChampionEncounter()
-        {
-            me->GetMotionMaster()->MovePoint(1, 735.81f, 661.92f, 412.39f);
-
-            if (me->SummonCreature(uiArgentChampion, SpawnPosition))
+            if (GetData(EVENT_WAVES) == IN_PROGRESS)
             {
-                for (uint8 i = 0; i < 3; ++i)
+                switch(events.ExecuteEvent())
                 {
-                    if (Creature* pTrash = me->SummonCreature(NPC_ARGENT_LIGHWIELDER, SpawnPosition))
-                        pTrash->AI()->SetData(i, 0);
-                    if (Creature* pTrash = me->SummonCreature(NPC_ARGENT_MONK, SpawnPosition))
-                        pTrash->AI()->SetData(i, 0);
-                    if (Creature* pTrash = me->SummonCreature(NPC_PRIESTESS, SpawnPosition))
-                        pTrash->AI()->SetData(i, 0);
+                    case 1:
+                        // Future texts?
+                        events.ScheduleEvent(2, 3000);
+                        break;
+                    case 2:
+                        // Start attack of first wave of adds
+                        if (!addsAttacking)
+                        {
+                            for (uint8 i=0; i<3; i++)
+                            {
+                                if (Creature* add = me->GetCreature(*me, addsGUID[0][i]))
+                                {
+                                    add->RemoveAurasDueToSpell(SPELL_MOUNT_LANCE_STAND);
+                                    add->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                                    add->SetReactState(REACT_AGGRESSIVE);
+                                    add->setFaction(16);
+                                    AggroAllPlayers(add);
+                                }
+                            }
+                            addsAttacking = true;
+                            events.ScheduleEvent(2, 1000);
+                        } else // Wait for the death of all of them
+                        {
+                            defeatedCount = 0;
+                            for (uint8 i=0; i<3; i++)
+                                if (Creature* add = me->GetCreature(*me, addsGUID[0][i]))
+                                    if (add->isDead())
+                                        defeatedCount++;
+
+                            if (defeatedCount>=3)
+                            {
+                                defeatedCount = 0;
+                                addsAttacking = false;
+                                events.ScheduleEvent(3, 4000);
+                            } else
+                                events.ScheduleEvent(2, 1000);
+                        }
+                        break;
+                    case 3:
+                        // Despawn previous wave
+                        for (uint8 i=0; i<3; i++)
+                            if (Creature* add = me->GetCreature(*me, addsGUID[0][i]))
+                                add->DespawnOrUnsummon();
+
+                        // Start attack of second wave of adds
+                        if (!addsAttacking)
+                        {
+                            for (uint8 i=0; i<3; i++)
+                            {
+                                if (Creature* add = me->GetCreature(*me, addsGUID[1][i]))
+                                {
+                                    add->RemoveAurasDueToSpell(SPELL_MOUNT_LANCE_STAND);
+                                    add->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                                    add->SetReactState(REACT_AGGRESSIVE);
+                                    add->setFaction(16);
+                                    AggroAllPlayers(add);
+                                }
+                            }
+                            addsAttacking = true;
+                            events.ScheduleEvent(3, 1000);
+                        } else // Wait for the death of all of them
+                        {
+                            defeatedCount = 0;
+                            for (uint8 i=0; i<3; i++)
+                                if (Creature* add = me->GetCreature(*me, addsGUID[1][i]))
+                                    if (add->isDead())
+                                        defeatedCount++;
+
+                            if (defeatedCount>=3)
+                            {
+                                defeatedCount = 0;
+                                addsAttacking = false;
+                                events.ScheduleEvent(4, 4000);
+                            } else
+                                events.ScheduleEvent(3, 1000);
+                        }
+                        break;
+                    case 4:
+                        // Despawn previous wave
+                        for (uint8 i=0; i<3; i++)
+                            if (Creature* add = me->GetCreature(*me, addsGUID[1][i]))
+                                add->DespawnOrUnsummon();
+
+                        // Start attack of third wave of adds
+                        if (!addsAttacking)
+                        {
+                            for (uint8 i=0; i<3; i++)
+                            {
+                                if (Creature* add = me->GetCreature(*me, addsGUID[2][i]))
+                                {
+                                    add->RemoveAurasDueToSpell(SPELL_MOUNT_LANCE_STAND);
+                                    add->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                                    add->SetReactState(REACT_AGGRESSIVE);
+                                    add->setFaction(16);
+                                    AggroAllPlayers(add);
+                                }
+                            }
+                            addsAttacking = true;
+                            events.ScheduleEvent(4, 1000);
+                        } else // Wait for the death of all of them
+                        {
+                            defeatedCount = 0;
+                            for (uint8 i=0; i<3; i++)
+                                if (Creature* add = me->GetCreature(*me, addsGUID[2][i]))
+                                    if (add->isDead())
+                                        defeatedCount++;
+
+                            if (defeatedCount>=3)
+                            {
+                                defeatedCount = 0;
+                                addsAttacking = false;
+                                events.ScheduleEvent(5, 4000);
+                            } else
+                                events.ScheduleEvent(4, 1000);
+                        }
+                        break;
+                    case 5:
+                        // Despawn previous wave
+                        for (uint8 i=0; i<3; i++)
+                            if (Creature* add = me->GetCreature(*me, addsGUID[2][i]))
+                                add->DespawnOrUnsummon();
+
+                        // Start attack of wave of bosses
+                        if (!addsAttacking)
+                        {
+                            for (uint8 i=0; i<3; i++)
+                            {
+                                if (Creature* add = me->GetCreature(*me, bossGUID[i]))
+                                {
+                                    add->RemoveAurasDueToSpell(SPELL_MOUNT_LANCE_STAND);
+                                    add->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                                    add->SetReactState(REACT_AGGRESSIVE);
+                                    add->setFaction(16);
+                                    AggroAllPlayers(add);
+                                }
+                            }
+                            addsAttacking = true;
+                            events.ScheduleEvent(5, 1000);
+                        } else // Wait for the death of all of them
+                        {
+                            defeatedCount = 0;
+                            for (uint8 i=0; i<3; i++)
+                                if (Creature* add = me->GetCreature(*me, bossGUID[i]))
+                                    if (add->AI()->GetData(DATA_CHAMPION_DEFEATED) == 1)
+                                        defeatedCount++;
+
+                            if (defeatedCount>=3)
+                            {
+                                defeatedCount = 0;
+                                addsAttacking = false;
+                                events.ScheduleEvent(6, 0);
+                            } else
+                                events.ScheduleEvent(5, 1000);
+                        }
+                        break;
+                    case 6:
+                        // Despawn boss wave
+                        for (uint8 i=0; i<3; i++)
+                            if (Creature* add = me->GetCreature(*me, bossGUID[i]))
+                                add->DespawnOrUnsummon();
+
+                        events.Reset();
+                        SetData(EVENT_WAVES, DONE);
+                        SetData(EVENT_CHAMPIONS, IN_PROGRESS);
+                        instance->SetData(MINION_ENCOUNTER, DONE);
+                        instance->SetData(BOSS_GRAND_CHAMPIONS, SPECIAL);
+                        break;
                 }
             }
-        }
 
-        void SetGrandChampionsForEncounter()
-        {
-            uiFirstBoss = urand(0, 4);
-
-            while (uiSecondBoss == uiFirstBoss || uiThirdBoss == uiFirstBoss || uiThirdBoss == uiSecondBoss)
+            if (GetData(EVENT_CHAMPIONS) == IN_PROGRESS)
             {
-                uiSecondBoss = urand(0, 4);
-                uiThirdBoss = urand(0, 4);
-            }
-        }
-
-        void SetArgentChampion()
-        {
-           uint8 uiTempBoss = urand(0, 1);
-
-           switch (uiTempBoss)
-           {
-                case 0:
-                    uiArgentChampion = NPC_EADRIC;
-                    break;
-                case 1:
-                    uiArgentChampion = NPC_PALETRESS;
-                    break;
-           }
-        }
+                switch(events.ExecuteEvent())
+                {
+                    case 1:
+                        AreAllPlayersMounted(true);
+                        events.ScheduleEvent(2, 0);
+                        break;
+                    case 2:
+                        for (uint8 i=0; i<3; i++)
+                        {
+                            if (Creature* boss = me->SummonCreature(bossEntry[i], GrandChampionSpawnPosition))
+                            {
+                                bossGUID[i] = boss->GetGUID();
+                                boss->SetTarget(stalkerGUID);
+                                // Save current boss entry to inst for achievement check
+                                instance->SetData64(DATA_GRAND_CHAMPION_GUID, boss->GetGUID());
+                                instance->SetData(DATA_GRAND_CHAMPION_ENTRY, boss->GetEntry());
+                                // Prevent bosses from falling down the ground
+                                boss->SetPosition(boss->GetPositionX(), boss->GetPositionY(), boss->GetPositionZ()+0.1f, boss->GetOrientation());
+                                // Set positions
+                                switch(i)
+                                {
+                                    case 1: boss->GetMotionMaster()->MoveFollow(me->GetCreature(*me, bossGUID[0]), 5.0f, (M_PI / 2) + 0.5f); break;
+                                    case 2: boss->GetMotionMaster()->MoveFollow(me->GetCreature(*me, bossGUID[0]), 5.0f, (M_PI / 2 + M_PI) - 0.5f); break;
+                                }
+                            }
+                        }
+                        events.ScheduleEvent(3, 2000);
+                        break;
+                    case 3:
+                        for (uint8 i=0; i<3; i++)
+                            if (Creature* boss = me->GetCreature(*me, bossGUID[i]))
+                            {
+                                if (Creature* tirion = me->GetCreature(*me, instance->GetData64(DATA_TIRION)))
+                                    boss->SetFacingToObject(tirion);
+                                boss->SetHomePosition(boss->GetPositionX(), boss->GetPositionY(), boss->GetPositionZ() + 1.0f, boss->GetOrientation());
+                                boss->SetReactState(REACT_AGGRESSIVE);
+                                boss->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC);
+                            }
+                        events.ScheduleEvent(4, 10000);
+                        break;
+                    case 4: // Wait for the death of all of them
+                        if (instance->GetData(BOSS_GRAND_CHAMPIONS) == IN_PROGRESS)
+                        {
+                            for (uint8 i=0; i<3; i++)
+                                if (Creature* boss = me->GetCreature(*me, bossGUID[i]))
+                                    if (!boss->isInCombat())
+                                        AggroAllPlayers(boss);
+                        }
 
-        void StartEncounter()
-        {
-            if (!instance)
-                return;
+                        defeatedCount = 0;
+                        for (uint8 i=0; i<3; i++)
+                            if (Creature* boss = me->GetCreature(*me, bossGUID[i]))
+                                if (boss->AI()->GetData(DATA_CHAMPION_DEFEATED) == 1)
+                                    defeatedCount++;
 
-            me->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+                        if (defeatedCount>=3)
+                        {
+                            defeatedCount = 0;
+                            addsAttacking = false;
+                            events.ScheduleEvent(5, 0);
+                        } else
+                            events.ScheduleEvent(4, 1000);
+                        break;
+                    case 5:
+                        for (uint8 i=0; i<3; i++)
+                            if (Creature* boss = me->GetCreature(*me, bossGUID[i]))
+                            {
+                                boss->GetMotionMaster()->MovePoint(0, OutStadiumPosition);
+                                boss->DespawnOrUnsummon(4000);
+                            }
+                        SetData(EVENT_CHAMPIONS, DONE);
+                        instance->SetData(BOSS_GRAND_CHAMPIONS, DONE);
+                        break;
+                }
+            }
 
-            if (instance->GetData(BOSS_BLACK_KNIGHT) == NOT_STARTED)
+            if (GetData(EVENT_INTRO_ARGENT) == IN_PROGRESS)
             {
-                if (instance->GetData(BOSS_ARGENT_CHALLENGE_E) == NOT_STARTED && instance->GetData(BOSS_ARGENT_CHALLENGE_P) == NOT_STARTED)
+                switch(events.ExecuteEvent())
                 {
-                    if (instance->GetData(BOSS_GRAND_CHAMPIONS) == NOT_STARTED)
-                        me->AI()->SetData(DATA_START, 0);
+                    case 1:
+                        if (Creature* tirion = me->GetCreature(*me, instance->GetData64(DATA_TIRION)))
+                            tirion->AI()->Talk(SAY_TIRION_INTRO_ARGENT_1);
+                        // Open door
+                        if (GameObject* pGO = GameObject::GetGameObject(*me, instance->GetData64(DATA_MAIN_GATE)))
+                            instance->HandleGameObject(pGO->GetGUID(), true);
+                        events.ScheduleEvent(2, 2000);
+                        break;
+                    case 2:
+                        // Summon 1st wave
+                        // The main add will move, and the two other will only follow him
+                        if (Creature* mainAdd = me->SummonCreature(NPC_ARGENT_LIGHWIELDER, SpawnPosition))
+                        {
+                            addsGUID[0][0] = mainAdd->GetGUID();
+                            mainAdd->SetTarget(stalkerGUID);
+
+                            for (uint8 i = 0; i < 2; ++i)
+                            {
+                                uint32 addEntry = 0;
+                                switch(i)
+                                {
+                                    case 0: addEntry = NPC_ARGENT_MONK; break;
+                                    case 1: addEntry = NPC_ARGENT_PRIESTESS; break;
+                                }
+
+                                if (Creature* add = me->SummonCreature(addEntry, SpawnPosition, TEMPSUMMON_MANUAL_DESPAWN))
+                                {
+                                    add->SetTarget(stalkerGUID);
+                                    addsGUID[0][i+1] = add->GetGUID();
+                                    switch(i)
+                                    {
+                                        case 0: add->GetMotionMaster()->MoveFollow(mainAdd, 1.0f, (M_PI / 2) + 0.5f); break;
+                                        case 1: add->GetMotionMaster()->MoveFollow(mainAdd, 1.0f, (M_PI / 2 + M_PI) - 0.5f); break;
+                                    }
+                                }
+                            }
+                        }
+                        events.ScheduleEvent(3, 2000);
+                        break;
+                    case 3:
+                        // Move first wave to his position
+                        if (Creature* mainAdd1 = me->GetCreature(*me, addsGUID[0][0]))
+                            mainAdd1->GetMotionMaster()->MovePoint(0, ArgentSoldierPosition[0]);
 
-                    if (instance->GetData(BOSS_GRAND_CHAMPIONS) == DONE)
-                        DoStartArgentChampionEncounter();
-                }
+                        events.ScheduleEvent(4, 3000);
+                        break;
+                    case 4:
+                        // Refresh the adds position
+                        for (uint8 i=0; i<1; i++)
+                        {
+                            if (Creature* mainAdd = me->GetCreature(*me, addsGUID[i][0]))
+                            {
+                                mainAdd->SetFacingToObject(me);
+                                for (uint8 j = 0; j<3; j++)
+                                {
+                                    if (Creature* add = me->GetCreature(*me, addsGUID[i][j]))
+                                    {
+                                        switch(j)
+                                        {
+                                            case 1: add->GetMotionMaster()->MoveFollow(mainAdd, 1.0f, (M_PI / 2) + 0.5f); break;
+                                            case 2: add->GetMotionMaster()->MoveFollow(mainAdd, 1.0f, (M_PI / 2 + M_PI) - 0.5f); break;
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                        events.ScheduleEvent(5, 3000);
+                        break;
+                    case 5:
+                        // Summon 2nd wave
+                        if (Creature* mainAdd = me->SummonCreature(NPC_ARGENT_LIGHWIELDER, SpawnPosition))
+                        {
+                            addsGUID[1][0] = mainAdd->GetGUID();
+                            mainAdd->SetTarget(stalkerGUID);
+
+                            for (uint8 i = 0; i < 2; ++i)
+                            {
+                                uint32 addEntry = 0;
+                                switch(i)
+                                {
+                                    case 0: addEntry = NPC_ARGENT_MONK; break;
+                                    case 1: addEntry = NPC_ARGENT_PRIESTESS; break;
+                                }
+
+                                if (Creature* add = me->SummonCreature(addEntry, SpawnPosition, TEMPSUMMON_MANUAL_DESPAWN))
+                                {
+                                    add->SetTarget(stalkerGUID);
+                                    addsGUID[1][i+1] = add->GetGUID();
+                                    switch(i)
+                                    {
+                                        case 0: add->GetMotionMaster()->MoveFollow(mainAdd, 1.0f, (M_PI / 2) + 0.5f); break;
+                                        case 1: add->GetMotionMaster()->MoveFollow(mainAdd, 1.0f, (M_PI / 2 + M_PI) - 0.5f); break;
+                                    }
+                                }
+                            }
+                        }
+                        events.ScheduleEvent(6, 5000);
+                        break;
+                    case 6:
+                        // Move first wave to the new position
+                        if (Creature* mainAdd1 = me->GetCreature(*me, addsGUID[0][0]))
+                            mainAdd1->GetMotionMaster()->MovePoint(0, ArgentSoldierPosition[1]);
 
-               if ((instance->GetData(BOSS_GRAND_CHAMPIONS) == DONE &&
-                   instance->GetData(BOSS_ARGENT_CHALLENGE_E) == DONE) ||
-                   instance->GetData(BOSS_ARGENT_CHALLENGE_P) == DONE)
-                    me->SummonCreature(VEHICLE_BLACK_KNIGHT, 769.834f, 651.915f, 447.035f, 0);
-            }
-        }
+                        // Move second wave to the new position
+                        if (Creature* mainAdd2 = me->GetCreature(*me, addsGUID[1][0]))
+                            mainAdd2->GetMotionMaster()->MovePoint(0, ArgentSoldierPosition[0]);
 
-        void AggroAllPlayers(Creature* temp)
-        {
-            Map::PlayerList const &PlList = me->GetMap()->GetPlayers();
+                        events.ScheduleEvent(7, 4000);
+                        break;
+                    case 7:
+                        // Refresh the adds position
+                        for (uint8 i=0; i<2; i++)
+                        {
+                            if (Creature* mainAdd = me->GetCreature(*me, addsGUID[i][0]))
+                            {
+                                mainAdd->SetFacingToObject(me);
+                                for (uint8 j = 0; j<3; j++)
+                                {
+                                    if (Creature* add = me->GetCreature(*me, addsGUID[i][j]))
+                                    {
+                                        switch(j)
+                                        {
+                                            case 1: add->GetMotionMaster()->MoveFollow(mainAdd, 1.0f, (M_PI / 2) + 0.5f); break;
+                                            case 2: add->GetMotionMaster()->MoveFollow(mainAdd, 1.0f, (M_PI / 2 + M_PI) - 0.5f); break;
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                        events.ScheduleEvent(8, 4000);
+                        break;
+                    case 8:
+                        // Summon 3rd wave
+                        if (Creature* mainAdd = me->SummonCreature(NPC_ARGENT_LIGHWIELDER, SpawnPosition))
+                        {
+                            addsGUID[2][0] = mainAdd->GetGUID();
+                            mainAdd->SetTarget(stalkerGUID);
+
+                            for (uint8 i = 0; i < 2; ++i)
+                            {
+                                uint32 addEntry = 0;
+                                switch(i)
+                                {
+                                    case 0: addEntry = NPC_ARGENT_MONK; break;
+                                    case 1: addEntry = NPC_ARGENT_PRIESTESS; break;
+                                }
+
+                                if (Creature* add = me->SummonCreature(addEntry, SpawnPosition, TEMPSUMMON_MANUAL_DESPAWN))
+                                {
+                                    add->SetTarget(stalkerGUID);
+                                    addsGUID[2][i+1] = add->GetGUID();
+                                    switch(i)
+                                    {
+                                        case 0: add->GetMotionMaster()->MoveFollow(mainAdd, 1.0f, (M_PI / 2) + 0.5f); break;
+                                        case 1: add->GetMotionMaster()->MoveFollow(mainAdd, 1.0f, (M_PI / 2 + M_PI) - 0.5f); break;
+                                    }
+                                }
+                            }
+                        }
+                        events.ScheduleEvent(9, 4000);
+                        break;
+                    case 9:
+                        // Move second wave to the new position
+                        if (Creature* mainAdd2 = me->GetCreature(*me, addsGUID[1][0]))
+                            mainAdd2->GetMotionMaster()->MovePoint(0, ArgentSoldierPosition[2]);
 
-            if (PlList.isEmpty())
-                return;
+                        // Move third wave to the new position
+                        if (Creature* mainAdd3 = me->GetCreature(*me, addsGUID[2][0]))
+                            mainAdd3->GetMotionMaster()->MovePoint(0, ArgentSoldierPosition[0]);
 
-            for (Map::PlayerList::const_iterator i = PlList.begin(); i != PlList.end(); ++i)
-            {
-                if (Player* player = i->getSource())
-                {
-                    if (player->isGameMaster())
-                        continue;
+                        events.ScheduleEvent(10, 4000);
+                        break;
+                    case 10:
+                        // Refresh the adds position
+                        for (uint8 i=0; i<3; i++)
+                        {
+                            if (Creature* mainAdd = me->GetCreature(*me, addsGUID[i][0]))
+                            {
+                                mainAdd->SetFacingToObject(me);
+                                for (uint8 j = 0; j<3; j++)
+                                {
+                                    if (Creature* add = me->GetCreature(*me, addsGUID[i][j]))
+                                    {
+                                        switch(j)
+                                        {
+                                            case 1: add->GetMotionMaster()->MoveFollow(mainAdd, 1.0f, (M_PI / 2) + 0.5f); break;
+                                            case 2: add->GetMotionMaster()->MoveFollow(mainAdd, 1.0f, (M_PI / 2 + M_PI) - 0.5f); break;
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                        events.ScheduleEvent(11, 4000);
+                        break;
+                    case 11:
+                        // Summon the boss
+                        bool chance;
+                        chance = urand(0, 1);
+                        if (Creature* boss = me->SummonCreature(chance ? NPC_EADRIC : NPC_PALETRESS, SpawnPosition))
+                        {
+                            AnnounceChampion(boss);
+                            bossGUID[0] = boss->GetGUID();
+                        }
+                        events.ScheduleEvent(12, 4000);
+                        break;
+                    case 12:
+                        // Set home positions, in case of wipe, this avoids summons goin back to the SpawnPos
+                        if (Creature* boss = me->GetCreature(*me, bossGUID[0]))
+                        {
+                            boss->SetHomePosition(boss->GetPositionX(), boss->GetPositionY(), boss->GetPositionZ(), boss->GetOrientation());
+                            switch (boss->GetEntry())
+                            {
+                                case NPC_EADRIC: boss->AI()->Talk(SAY_EADRIC_INTRO); break;
+                                case NPC_PALETRESS: boss->AI()->Talk(SAY_PALETRESS_INTRO_1); break;
+                            }
+                        }
 
-                    if (player->isAlive())
-                    {
-                        temp->SetHomePosition(me->GetPositionX(), me->GetPositionY(), me->GetPositionZ(), me->GetOrientation());
-                        temp->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-                        temp->SetReactState(REACT_AGGRESSIVE);
-                        temp->SetInCombatWith(player);
-                        player->SetInCombatWith(temp);
-                        temp->AddThreat(player, 0.0f);
-                    }
+                        for (uint8 i=0; i<3; i++)
+                            for (uint8 j=0; j<3; j++)
+                                if (Creature* add = me->GetCreature(*me, addsGUID[i][j]))
+                                {
+                                    add->SetFacingToObject(me);
+                                    add->SetHomePosition(add->GetPositionX(), add->GetPositionY(), add->GetPositionZ(), add->GetOrientation());
+                                }
+                        events.ScheduleEvent(13, 4000);
+                        break;
+                    case 13:
+                        // Set home positions, in case of wipe, this avoids summons goin back to the SpawnPos
+                        if (Creature* boss = me->GetCreature(*me, bossGUID[0]))
+                        {
+                            switch (boss->GetEntry())
+                            {
+                                case NPC_PALETRESS: boss->AI()->Talk(SAY_PALETRESS_INTRO_2); break;
+                            }
+                        }
+                        // Move to the door position
+                        me->SetUnitMovementFlags(MOVEMENTFLAG_WALKING);
+                        me->GetMotionMaster()->MovePoint(0, AnnouncerPosition);
+                        me->SetTarget(stalkerGUID);
+                        events.ScheduleEvent(14, 19000);
+                        break;
+                    case 14:
+                        //Close Door
+                        if (GameObject* pGO = GameObject::GetGameObject(*me, instance->GetData64(DATA_MAIN_GATE)))
+                            instance->HandleGameObject(pGO->GetGUID(), false);
+
+                        if (Creature* tirion = me->GetCreature(*me, instance->GetData64(DATA_TIRION)))
+                            tirion->AI()->Talk(SAY_TIRION_INTRO_ARGENT_2);
+
+                        events.Reset();
+                        SetData(EVENT_INTRO_ARGENT, DONE);
+                        SetData(EVENT_WAVES_ARGENT, IN_PROGRESS);
+                        break;
                 }
             }
-        }
-
-       void UpdateAI(const uint32 uiDiff)
-        {
-            ScriptedAI::UpdateAI(uiDiff);
 
-            if (uiTimer <= uiDiff)
+            if (GetData(EVENT_WAVES_ARGENT) == IN_PROGRESS)
             {
-                switch (uiPhase)
+                switch(events.ExecuteEvent())
                 {
                     case 1:
-                        DoSummonGrandChampion(uiSecondBoss);
-                        NextStep(10000, true);
+                        // Future texts?
+                        events.ScheduleEvent(2, 3000);
                         break;
                     case 2:
-                        DoSummonGrandChampion(uiThirdBoss);
-                        NextStep(0, false);
+                        // Start attack of first wave of adds
+                        if (!addsAttacking)
+                        {
+                            for (uint8 j=0; j<3; j++)
+                            {
+                                for (uint8 i=0; i<3; i++)
+                                {
+                                    if (Creature* add = me->GetCreature(*me, addsGUID[j][i]))
+                                    {
+                                        add->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                                        add->SetReactState(REACT_AGGRESSIVE);
+                                        add->setFaction(16);
+                                    }
+                                }
+                            }
+                            addsAttacking = true;
+                            events.ScheduleEvent(2, 1000);
+                        } else // Wait for the death of all of them
+                        {
+                            defeatedCount = 0;
+
+                            for (uint8 j=0; j<3; j++)
+                                for (uint8 i=0; i<3; i++)
+                                    if (Creature* add = me->GetCreature(*me, addsGUID[j][i]))
+                                    {
+                                        if (add->isDead())
+                                            defeatedCount++;
+                                    } else defeatedCount++;
+
+                            if (defeatedCount>=9)
+                            {
+                                defeatedCount = 0;
+                                addsAttacking = false;
+                                instance->SetData(MINION_ENCOUNTER, DONE);
+                                events.ScheduleEvent(3, 4000);
+                            } else
+                                events.ScheduleEvent(2, 1000);
+                        }
                         break;
                     case 3:
-                        if (!Champion1List.empty())
+                        // Despawn previous wave
+                        for (uint8 j=0; j<3; j++)
+                            for (uint8 i=0; i<3; i++)
+                                if (Creature* add = me->GetCreature(*me, addsGUID[j][i]))
+                                    add->DespawnOrUnsummon();
+
+                        // Prepare the Argent Champion for the fight
+                        if (!addsAttacking)
+                        {
+                            if (Creature* boss = me->GetCreature(*me, bossGUID[0]))
+                            {
+                                boss->SetUnitMovementFlags(MOVEMENTFLAG_WALKING);
+                                boss->GetMotionMaster()->MovePoint(0, ArgentSoldierPosition[0]);
+                                boss->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                                boss->SetReactState(REACT_AGGRESSIVE);
+                                boss->setFaction(16);
+                            }
+                            addsAttacking = true;
+                            events.ScheduleEvent(3, 1000);
+                        } else // Wait for his/her death
+                        {
+                            if (Creature* boss = me->GetCreature(*me, bossGUID[0]))
+                            {
+                                if (boss->AI()->GetData(DATA_CHAMPION_DEFEATED) == 1)
+                                    events.ScheduleEvent(4, 0);
+                                else
+                                    events.ScheduleEvent(3, 1000);
+                            }
+                        }
+                        break;
+                    case 4:
+                        // Mark encounter as completed
+                        events.Reset();
+                        SetData(EVENT_WAVES_ARGENT, DONE);
+                        if (Creature* boss = me->GetCreature(*me, bossGUID[0]))
                         {
-                            for (std::list<uint64>::const_iterator itr = Champion1List.begin(); itr != Champion1List.end(); ++itr)
-                                if (Creature* summon = Unit::GetCreature(*me, *itr))
-                                    AggroAllPlayers(summon);
-                            NextStep(0, false);
+                            if (boss->GetEntry() == NPC_EADRIC)
+                                instance->SetData(BOSS_ARGENT_CHALLENGE_E, DONE);
+                            else
+                                instance->SetData(BOSS_ARGENT_CHALLENGE_P, DONE);
                         }
                         break;
                 }
-            } else uiTimer -= uiDiff;
-
-            if (!UpdateVictim())
-                return;
-        }
+            }
 
-        void JustSummoned(Creature* summon)
-        {
-            if (instance && instance->GetData(BOSS_GRAND_CHAMPIONS) == NOT_STARTED)
+            if (GetData(EVENT_BLACK_KNIGHT_INTRO) == IN_PROGRESS)
             {
-                summon->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-                summon->SetReactState(REACT_PASSIVE);
+                switch(events.ExecuteEvent())
+                {
+                    case 1:
+                        if (Creature* tirion = me->GetCreature(*me, instance->GetData64(DATA_TIRION)))
+                            tirion->AI()->Talk(SAY_TIRION_INTRO_BK_1);
+
+                        events.ScheduleEvent(2, 3000);
+                        break;
+                    case 2:
+                        if (Creature* mount = me->GetCreature(*me, instance->GetData64(DATA_BLACK_KNIGHT_GRYPHON)))
+                        {
+                            mount->SetPhaseMask(1, true);
+                            if (Creature* knight = me->GetCreature(*me, instance->GetData64(DATA_BLACK_KNIGHT)))
+                                knight->SetPhaseMask(1, true);
+                            Talk(SAY_ANNOUNCER_BK);
+                            mount->AI()->SetData(1, 0);
+                            me->SetTarget(mount->GetGUID());
+                        }
+                        events.ScheduleEvent(3, 15000);
+                        break;
+                    case 3:
+                        if (Creature* blackKinght = me->GetCreature(*me, instance->GetData64(DATA_BLACK_KNIGHT)))
+                        {
+                            if (blackKinght->GetVehicle())
+                                events.ScheduleEvent(3, 2000);
+                            else
+                            {
+                                blackKinght->SetTarget(me->GetGUID());
+                                me->SetTarget(blackKinght->GetGUID());
+                                events.ScheduleEvent(4, 2000);
+                            }
+                        }
+                        break;
+                    case 4:
+                        if (Creature* blackKinght = me->GetCreature(*me, instance->GetData64(DATA_BLACK_KNIGHT)))
+                        {
+                            blackKinght->AI()->Talk(SAY_BK_INTRO_1);
+                            blackKinght->AI()->DoCast(SPELL_DEATH_RESPITE_INTRO);
+                        }
+                        events.ScheduleEvent(5, 4000);
+                        break;
+                    case 5:
+                        if (Creature* blackKinght = me->GetCreature(*me, instance->GetData64(DATA_BLACK_KNIGHT)))
+                        {
+                            blackKinght->AI()->DoCast(me, SPELL_DEATH_PUSH_INTRO);
+                            blackKinght->SetTarget(0);
+                        }
+                        events.ScheduleEvent(6, 2000);
+                        break;
+                    case 6:
+                        if (Creature* tirion = me->GetCreature(*me, instance->GetData64(DATA_TIRION)))
+                        {
+                            tirion->AI()->Talk(SAY_TIRION_INTRO_BK_2);
+                            if (Creature* blackKinght = me->GetCreature(*me, instance->GetData64(DATA_BLACK_KNIGHT)))
+                            {
+                                DoCast(57626); // Feign death
+                                blackKinght->SetTarget(tirion->GetGUID());
+                            }
+                        }
+                        events.ScheduleEvent(7, 3000);
+                        break;
+                    case 7:
+                        if (Creature* blackKinght = me->GetCreature(*me, instance->GetData64(DATA_BLACK_KNIGHT)))
+                            blackKinght->AI()->Talk(SAY_BK_INTRO_2);
+                        events.ScheduleEvent(8, 9000);
+                        break;
+                    case 8:
+                        if (Creature* blackKinght = me->GetCreature(*me, instance->GetData64(DATA_BLACK_KNIGHT)))
+                            blackKinght->AI()->Talk(SAY_BK_INTRO_3);
+                        events.ScheduleEvent(9, 5000);
+                        break;
+                    case 9:
+                        if (instance->GetData(DATA_TEAM) == HORDE)
+                        {
+                            if (Creature* garrosh = me->GetCreature(*me, instance->GetData64(DATA_GARROSH)))
+                                garrosh->AI()->Talk(SAY_GARROSH_INTRO_BK);
+                        } else
+                        {
+                            if (Creature* varian = me->GetCreature(*me, instance->GetData64(DATA_VARIAN)))
+                                varian->AI()->Talk(SAY_VARIAN_INTRO_BK);
+                        }
+
+                        SetData(EVENT_BLACK_KNIGHT_INTRO, DONE);
+                        events.Reset();
+                        if (Creature* blackKinght = me->GetCreature(*me, instance->GetData64(DATA_BLACK_KNIGHT)))
+                        {
+                            blackKinght->SetHomePosition(blackKinght->GetPositionX(), blackKinght->GetPositionY(), blackKinght->GetPositionZ(), blackKinght->GetOrientation());
+                            blackKinght->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                            blackKinght->SetReactState(REACT_AGGRESSIVE);
+                            blackKinght->Kill(me);
+                        }
+                        break;
+                }
             }
         }
 
-        void SummonedCreatureDespawn(Creature* summon)
+        /**
+        Used for checking if players are mounted before starting gauntlet
+        and teleporting and unmounting them after defeating the mounted waves.
+        */
+        bool AreAllPlayersMounted(bool dismountAndTeleport = false)
         {
-            switch (summon->GetEntry())
-            {
-                case VEHICLE_DARNASSIA_NIGHTSABER:
-                case VEHICLE_EXODAR_ELEKK:
-                case VEHICLE_STORMWIND_STEED:
-                case VEHICLE_GNOMEREGAN_MECHANOSTRIDER:
-                case VEHICLE_IRONFORGE_RAM:
-                case VEHICLE_FORSAKE_WARHORSE:
-                case VEHICLE_THUNDER_BLUFF_KODO:
-                case VEHICLE_ORGRIMMAR_WOLF:
-                case VEHICLE_SILVERMOON_HAWKSTRIDER:
-                case VEHICLE_DARKSPEAR_RAPTOR:
-                    me->AI()->SetData(DATA_LESSER_CHAMPIONS_DEFEATED, 0);
-                    break;
-            }
+            Map::PlayerList const &PlList = me->GetMap()->GetPlayers();
+
+            if (PlList.isEmpty())
+                return false;
+
+            for (Map::PlayerList::const_iterator i = PlList.begin(); i != PlList.end(); ++i)
+                if (Player* player = i->getSource())
+                {
+                    if (player->isGameMaster())
+                        continue;
+
+                    if (player->isAlive())
+                    {
+                        if (Creature* mount = player->GetVehicleCreatureBase())
+                        {
+                            if (dismountAndTeleport)
+                            {
+                                player->ExitVehicle();
+                                mount->DespawnOrUnsummon();
+                            }
+                        } else if (!dismountAndTeleport)
+                            return false;
+
+                        if (dismountAndTeleport)
+                            player->NearTeleportTo(746.851f, 608.875f, 411.172f, 1.60308f);
+                    }
+                }
+
+            return true;
         }
     };
 
@@ -466,35 +1398,71 @@ public:
     bool OnGossipHello(Player* player, Creature* creature)
     {
         InstanceScript* instance = creature->GetInstanceScript();
+        uint32 gossipTextId = 0;
 
-        if (instance &&
-            ((instance->GetData(BOSS_GRAND_CHAMPIONS) == DONE &&
-            instance->GetData(BOSS_BLACK_KNIGHT) == DONE &&
-            instance->GetData(BOSS_ARGENT_CHALLENGE_E) == DONE) ||
-            instance->GetData(BOSS_ARGENT_CHALLENGE_P) == DONE))
-            return false;
-
-        if (instance &&
-            instance->GetData(BOSS_GRAND_CHAMPIONS) == NOT_STARTED &&
-            instance->GetData(BOSS_ARGENT_CHALLENGE_E) == NOT_STARTED &&
-            instance->GetData(BOSS_ARGENT_CHALLENGE_P) == NOT_STARTED &&
-            instance->GetData(BOSS_BLACK_KNIGHT) == NOT_STARTED)
-            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_START_EVENT1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
-        else if (instance)
+        if (player->isGameMaster())
+        {
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_START_EVENT1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_START_EVENT2, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_START_EVENT3, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
+            gossipTextId = player->GetGossipTextId(creature);
+        }
+        else if (instance->GetData(BOSS_GRAND_CHAMPIONS) != DONE)
+        {
+            if (CAST_AI(npc_announcer_toc5::npc_announcer_toc5AI, creature->AI())->AreAllPlayersMounted())
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_START_EVENT1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
+            gossipTextId = creature->GetEntry() == NPC_JAEREN ? GOSSIP_TEXT_NOT_MOUNTED_HORDE : GOSSIP_TEXT_NOT_MOUNTED_ALLIANCE;
+        }else if (instance->GetData(BOSS_ARGENT_CHALLENGE_E) != DONE && instance->GetData(BOSS_ARGENT_CHALLENGE_P) != DONE)
+        {
             player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_START_EVENT2, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+            gossipTextId = GOSSIP_TEXT_FACTION_CHAMPIONS_DEFEATED;
+        }
+        else
+        {
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_START_EVENT3, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
+            gossipTextId = GOSSIP_TEXT_ARGENT_CHAMPIONS_DEFEATED;
+        }
 
-        player->SEND_GOSSIP_MENU(player->GetGossipTextId(creature), creature->GetGUID());
+        player->SEND_GOSSIP_MENU(gossipTextId, creature->GetGUID());
 
         return true;
     }
 
-    bool OnGossipSelect(Player* player, Creature* creature, uint32 /*uiSender*/, uint32 uiAction)
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 /*uiSender*/, uint32 action)
     {
         player->PlayerTalkClass->ClearMenus();
-        if (uiAction == GOSSIP_ACTION_INFO_DEF+1)
+
+        // Remove chest (if any) before starting anything else
+        if (InstanceScript* instance = creature->GetInstanceScript())
+            if (GameObject* chest = GameObject::GetGameObject(*creature, instance->GetData64(DATA_CHEST)))
+                chest->RemoveFromWorld();
+
+        switch (action)
         {
-            player->CLOSE_GOSSIP_MENU();
-            CAST_AI(npc_announcer_toc5::npc_announcer_toc5AI, creature->AI())->StartEncounter();
+            case GOSSIP_ACTION_INFO_DEF:
+                if (creature->AI()->GetData(EVENT_INTRO) != IN_PROGRESS)
+                {
+                    creature->AI()->SetData(EVENT_INTRO, IN_PROGRESS);
+                    creature->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+                    player->CLOSE_GOSSIP_MENU();
+                }
+                break;
+            case GOSSIP_ACTION_INFO_DEF+1:
+                if (creature->AI()->GetData(EVENT_INTRO_ARGENT) != IN_PROGRESS)
+                {
+                    creature->AI()->SetData(EVENT_INTRO_ARGENT, IN_PROGRESS);
+                    creature->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+                    player->CLOSE_GOSSIP_MENU();
+                }
+                break;
+            case GOSSIP_ACTION_INFO_DEF+2:
+                if (creature->AI()->GetData(EVENT_BLACK_KNIGHT_INTRO) != IN_PROGRESS)
+                {
+                    creature->AI()->SetData(EVENT_BLACK_KNIGHT_INTRO, IN_PROGRESS);
+                    creature->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+                    player->CLOSE_GOSSIP_MENU();
+                }
+                break;
         }
 
         return true;
diff --git a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/trial_of_the_champion.h b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/trial_of_the_champion.h
index cb3a43a..a3eedbb 100644
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/trial_of_the_champion.h
+++ b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheChampion/trial_of_the_champion.h
@@ -25,25 +25,103 @@ enum eData
     BOSS_ARGENT_CHALLENGE_E,
     BOSS_ARGENT_CHALLENGE_P,
     BOSS_BLACK_KNIGHT,
-    DATA_MOVEMENT_DONE,
-    DATA_LESSER_CHAMPIONS_DEFEATED,
-    DATA_START,
-    DATA_IN_POSITION,
-    DATA_ARGENT_SOLDIER_DEFEATED
+    MINION_ENCOUNTER,
+
+    DATA_TEAM,
+    DATA_CHAMPION_DEFEATED,
+    DATA_GRAND_CHAMPION_ENTRY,
+    DATA_GRAND_CHAMPION_GUID,
+    DATA_MEMORY_ENTRY,
+    DATA_I_VE_HAD_WORSE,
 };
 
 enum Data64
 {
     DATA_ANNOUNCER,
+    DATA_TIRION,
+    DATA_THRALL,
+    DATA_GARROSH,
+    DATA_VARIAN,
+    DATA_JAINA,
+
     DATA_MAIN_GATE,
+    DATA_PORTCULLIS,
+    DATA_CHEST,
 
-    DATA_GRAND_CHAMPION_VEHICLE_1,
-    DATA_GRAND_CHAMPION_VEHICLE_2,
-    DATA_GRAND_CHAMPION_VEHICLE_3,
+    DATA_BLACK_KNIGHT,
+    DATA_BLACK_KNIGHT_GRYPHON,
+};
 
-    DATA_GRAND_CHAMPION_1,
-    DATA_GRAND_CHAMPION_2,
-    DATA_GRAND_CHAMPION_3
+enum AnnouncerPhases
+{
+    EVENT_INTRO = 0, // Presentation of champions
+    EVENT_WAVES,
+    EVENT_CHAMPIONS,
+    EVENT_INTRO_ARGENT,
+    EVENT_WAVES_ARGENT,
+    EVENT_BLACK_KNIGHT_INTRO,
+    EVENTS_MAX,
+};
+
+enum achievementCriterias
+{
+    CRITERIA_CHAMPION_JACOB     = 11420,
+    CRITERIA_CHAMPION_LANA      = 12298,
+    CRITERIA_CHAMPION_COLOSOS   = 12299,
+    CRITERIA_CHAMPION_AMBROSE   = 12300,
+    CRITERIA_CHAMPION_JAELYNE   = 12301,
+
+    CRITERIA_CHAMPION_MOKRA     = 12302,
+    CRITERIA_CHAMPION_VISCERI   = 12303,
+    CRITERIA_CHAMPION_RUNOK     = 12304,
+    CRITERIA_CHAMPION_ERESSEA   = 12305,
+    CRITERIA_CHAMPION_ZULTORE   = 12306,
+
+    CRITERIA_CHAMPION_JACOB_H   = 12310,
+    CRITERIA_CHAMPION_LANA_H    = 12311,
+    CRITERIA_CHAMPION_COLOSOS_H = 12312,
+    CRITERIA_CHAMPION_AMBROSE_H = 12313,
+    CRITERIA_CHAMPION_JAELYNE_H = 12314,
+
+    CRITERIA_CHAMPION_MOKRA_H   = 12318,
+    CRITERIA_CHAMPION_VISCERI_H = 12319,
+    CRITERIA_CHAMPION_RUNOK_H   = 12320,
+    CRITERIA_CHAMPION_ERESSEA_H = 12321,
+    CRITERIA_CHAMPION_ZULTORE_H = 12322,
+
+    CRITERIA_MEMORY_HOGGER     = 11863,
+    CRITERIA_MEMORY_VANCLEEF   = 11904,
+    CRITERIA_MEMORY_MUTANUS    = 11905,
+    CRITERIA_MEMORY_HEROD      = 11906,
+    CRITERIA_MEMORY_LUCIFROM   = 11907,
+    CRITERIA_MEMORY_THUNDERAAN = 11908,
+    CRITERIA_MEMORY_CHROMAGGUS = 11909,
+    CRITERIA_MEMORY_HAKKAR     = 11910,
+    CRITERIA_MEMORY_VEKNILASH  = 11911,
+    CRITERIA_MEMORY_KALITHRESH = 11912,
+    CRITERIA_MEMORY_MALCHEZAAR = 11913,
+    CRITERIA_MEMORY_GRUUL      = 11914,
+    CRITERIA_MEMORY_VASHJ      = 11915,
+    CRITERIA_MEMORY_ARCHIMONDE = 11916,
+    CRITERIA_MEMORY_ILLIDAN    = 11917,
+    CRITERIA_MEMORY_DELRISSA   = 11918,
+    CRITERIA_MEMORY_MURU       = 11919,
+    CRITERIA_MEMORY_INGVAR     = 11920,
+    CRITERIA_MEMORY_CYANIGOSA  = 11921,
+    CRITERIA_MEMORY_ECK        = 11922,
+    CRITERIA_MEMORY_ONYXIA     = 11923,
+    CRITERIA_MEMORY_HEIGAN     = 11924,
+    CRITERIA_MEMORY_IGNIS      = 11925,
+    CRITERIA_MEMORY_VEZAX      = 11926,
+    CRITERIA_MEMORY_ALGALON    = 11927,
+
+    CRITERIA_I_VE_HAD_WORSE    = 11789,
+
+    SPELL_ACHIEVEMENT_CHAMPIONS = 68572,
+    SPELL_ACHIEVEMENT_PALETRESS = 68574,
+    SPELL_ACHIEVEMENT_MEMORIES  = 68206,
+    SPELL_ACHIEVEMENT_EADRIC    = 68575,
+    SPELL_ACHIEVEMENT_BLACK_KNIGHT = 68663,
 };
 
 enum eNpcs
@@ -62,34 +140,85 @@ enum eNpcs
     NPC_JAELYNE                 = 34657,
     NPC_LANA                    = 34703,
 
+    // Alliance Pre-Champs
+    NPC_STORMWIND_CHAMPION      = 35328,
+    NPC_IRONFORGE_CHAMPION      = 35329,
+    NPC_GNOMEREGAN_CHAMPION     = 35331,
+    NPC_DARNASSUS_CHAMPION      = 35332,
+    NPC_EXODAR_CHAMPION         = 35330,
+
+    // Horde Pre-Champs
+    NPC_ORGRIMMAR_CHAMPION      = 35314,
+    NPC_THUNDER_BLUFF_CHAMPION  = 35325,
+    NPC_UNDERCITY_CHAMPION      = 35327,
+    NPC_SENJIN_CHAMPION         = 35323,
+    NPC_SILVERMOON_CHAMPION     = 35326,
+
+    // Argent Champions
     NPC_EADRIC                  = 35119,
     NPC_PALETRESS               = 34928,
 
+    NPC_MEMORY_HOGGER           = 34942,
+    NPC_MEMORY_VANCLEEF         = 35028,
+    NPC_MEMORY_MUTANUS          = 35029,
+    NPC_MEMORY_HEROD            = 35030,
+    NPC_MEMORY_LUCIFROM         = 35031,
+    NPC_MEMORY_THUNDERAAN       = 35032,
+    NPC_MEMORY_CHROMAGGUS       = 35033,
+    NPC_MEMORY_HAKKAR           = 35034,
+    NPC_MEMORY_VEKNILASH        = 35036,
+    NPC_MEMORY_KALITHRESH       = 35037,
+    NPC_MEMORY_MALCHEZAAR       = 35038,
+    NPC_MEMORY_GRUUL            = 35039,
+    NPC_MEMORY_VASHJ            = 35040,
+    NPC_MEMORY_ARCHIMONDE       = 35041,
+    NPC_MEMORY_ILLIDAN          = 35042,
+    NPC_MEMORY_DELRISSA         = 35043,
+    NPC_MEMORY_MURU             = 35044,
+    NPC_MEMORY_INGVAR           = 35045,
+    NPC_MEMORY_CYANIGOSA        = 35046,
+    NPC_MEMORY_ECK              = 35047,
+    NPC_MEMORY_ONYXIA           = 35048,
+    NPC_MEMORY_HEIGAN           = 35049,
+    NPC_MEMORY_IGNIS            = 35050,
+    NPC_MEMORY_VEZAX            = 35051,
+    NPC_MEMORY_ALGALON          = 35052,
+
+    // Argen Pre-Champs
     NPC_ARGENT_LIGHWIELDER      = 35309,
     NPC_ARGENT_MONK             = 35305,
-    NPC_PRIESTESS               = 35307,
+    NPC_ARGENT_PRIESTESS        = 35307,
 
     NPC_BLACK_KNIGHT            = 35451,
 
     NPC_RISEN_JAEREN            = 35545,
     NPC_RISEN_ARELAS            = 35564,
+    NPC_RISEN_CHAMPION          = 35590,
 
+    // Announcers
     NPC_JAEREN                  = 35004,
-    NPC_ARELAS                  = 35005
+    NPC_ARELAS                  = 35005,
+
+    NPC_TIRION                  = 34996,
+    NPC_THRALL                  = 34994,
+    NPC_GARROSH                 = 34995,
+    NPC_VARIAN                  = 34990,
+    NPC_JAINA                   = 34992,
 };
 
 enum eGameObjects
 {
     GO_MAIN_GATE                = 195647,
+    GO_PORTCULLIS               = 195650,
 
     GO_CHAMPIONS_LOOT           = 195709,
-    GO_CHAMPIONS_LOOT_H            = 195710,
+    GO_CHAMPIONS_LOOT_H         = 195710,
 
     GO_EADRIC_LOOT              = 195374,
     GO_EADRIC_LOOT_H            = 195375,
 
     GO_PALETRESS_LOOT           = 195323,
-    GO_PALETRESS_LOOT_H            = 195324
+    GO_PALETRESS_LOOT_H         = 195324
 };
 
 enum eVehicles
@@ -125,4 +254,55 @@ enum eVehicles
     VEHICLE_BLACK_KNIGHT                            = 35491
 };
 
+enum IntroSpells
+{
+    SPELL_MOUNT_LANCE_STAND   = 64723,
+    SPELL_DEATH_RESPITE_INTRO = 66798,
+    SPELL_DEATH_PUSH_INTRO    = 66797,
+};
+
+static void BindPlayersToInstance(Creature* creature)
+{
+    Map* map = creature->GetMap();
+
+    if (map && map->IsDungeon() && map->IsRaidOrHeroicDungeon())
+    {
+        Map::PlayerList const &PlList = map->GetPlayers();
+        if (!PlList.isEmpty() && PlList.begin()->getSource())
+            ((InstanceMap*)map)->PermBindAllPlayers(PlList.begin()->getSource());
+    }
+};
+
+static void AggroAllPlayers(Creature* creature)
+{
+    Map::PlayerList const &PlList = creature->GetMap()->GetPlayers();
+
+    if (PlList.isEmpty())
+        return;
+
+    for (Map::PlayerList::const_iterator i = PlList.begin(); i != PlList.end(); ++i)
+    {
+        if (Player* player = i->getSource())
+        {
+            if (player->isGameMaster())
+                continue;
+
+            if (player->isAlive())
+            {
+                if (Unit* mount = player->GetVehicleBase())
+                {
+                    creature->SetInCombatWith(mount);
+                    mount->SetInCombatWith(creature);
+                    creature->AddThreat(mount, 0.0f);
+                }
+                else
+                {
+                    creature->SetInCombatWith(player);
+                    player->SetInCombatWith(creature);
+                    creature->AddThreat(player, 0.0f);
+                }
+            }
+        }
+    }
+};
 #endif
-- 
1.7.8.msysgit.0

